<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>fcc_utils API documentation</title>
<meta name="description" content="Utility functions for dimensionality reduction structural preservation analysis" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>fcc_utils</code></h1>
</header>
<section id="section-intro">
<p>Utility functions for dimensionality reduction structural preservation analysis</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
&#34;&#34;&#34;
Utility functions for dimensionality reduction structural preservation analysis
&#34;&#34;&#34;
import warnings

import matplotlib.pyplot as plt
import networkx as nx
import numpy as np
import pandas as pd
import scanpy as sc
from ot import wasserstein_1d
from scipy.spatial.distance import cdist, pdist
from scipy.stats import pearsonr
from sklearn.neighbors import kneighbors_graph
from sklearn.preprocessing import normalize

import seaborn as sns

sc.set_figure_params(dpi=90, color_map=&#34;viridis&#34;)
sns.set(style=&#34;white&#34;)


def arcsinh(adata, layer=None, norm=&#34;l1&#34;, scale=1000):
    &#34;&#34;&#34;
    Returns arcsinh-normalized values for each element in anndata counts matrix

    Parameters
    ----------

    adata : anndata.AnnData
        AnnData object
    layer : str, optional (default=None)
        name of layer to perform arcsinh-normalization on. if None, use `adata.X`
    norm : str {&#34;l1&#34;,&#34;l2&#34;}, optional (default=&#34;l1&#34;)
        normalization strategy prior to arcsinh transform. None=do not normalize data. 
        &#34;l1&#34;=divide each count by sum of counts for each cell. &#34;l2&#34;=divide each count 
        by sqrt of sum of squares of counts for cell.
    scale : float, optional (default=1000)
        factor to multiply normalized counts by

    Returns
    -------

    `adata` is edited in place to add `adata.layers[&#34;arcsinh_norm&#34;]`
    &#34;&#34;&#34;
    if layer is None:
        mat = adata.X
    else:
        mat = adata.layers[layer]

    adata.layers[&#34;arcsinh_norm&#34;] = np.arcsinh(normalize(mat, axis=1, norm=norm) * scale)


def knn_graph(dist_matrix, k, adata, save_rep=&#34;knn&#34;):
    &#34;&#34;&#34;
    Builds simple binary k-nearest neighbor graph and add to anndata object

    Parameters
    ----------

    dist_matrix : np.array
        distance matrix to calculate knn graph for (i.e. `pdist(adata.obsm[&#34;X_pca&#34;])`)
    k : int
        number of nearest neighbors to determine
    adata : anndata.AnnData
        AnnData object to add resulting graph to (in `.uns` slot)
    save_rep : str, optional (default=&#34;knn&#34;)
        name of `.uns` key to save knn graph to within adata

    Returns
    -------

    `adata` is edited in place, adding knn graph to `adata.uns[save_rep]`
    &#34;&#34;&#34;
    adata.uns[save_rep] = {
        &#34;graph&#34;: kneighbors_graph(
            dist_matrix, k, mode=&#34;connectivity&#34;, include_self=False, n_jobs=-1
        ).toarray(),
        &#34;k&#34;: k,
    }


def subset_uns_by_ID(adata, uns_keys, obs_col, IDs):
    &#34;&#34;&#34;
    Subsets symmetrical distance matrices and knn graphs in `adata.uns` by one or more 
    IDs defined in `adata.obs`

    Parameters
    ----------

    adata : anndata.AnnData
        AnnData object
    uns_keys : list of str
        list of keys in `adata.uns` to subset. new `adata.uns` keys will be saved with 
        ID appended to name (i.e. `adata.uns[&#34;knn&#34;]` -&gt; `adata.uns[&#34;knn_ID1&#34;]`)
    obs_col : str
        name of column in `adata.obs` to use as cell IDs (i.e. &#34;leiden&#34;)
    IDs : list of str
        list of IDs to include in subset

    Returns
    -------

    `adata` is edited in place, adding new `.uns` keys for each ID
    &#34;&#34;&#34;
    for key in uns_keys:
        tmp = adata.uns[key][
            adata.obs[obs_col].isin(IDs), :
        ]  # subset symmetrical uns matrix along axis 0
        tmp = tmp[
            :, adata.obs[obs_col].isin(IDs)
        ]  # subset symmetrical uns matrix along axis 1

        adata.uns[
            &#34;{}_{}&#34;.format(key, &#34;_&#34;.join([str(x) for x in IDs]))
        ] = tmp  # save new .uns key by appending IDs to original key name


def find_centroids(adata, use_rep, obs_col=&#34;leiden&#34;):
    &#34;&#34;&#34;
    Finds cluster centroids

    Parameters
    ----------

    adata : anndata.AnnData
        AnnData object
    use_rep : str
        &#34;X&#34; or `adata.obsm` key containing space to calculate centroids in 
        (i.e. &#34;X_pca&#34;)
    obs_col &#34;str, optional (default=&#34;leiden&#34;)
        `adata.obs` column name containing cluster IDs

    Returns
    -------

    `adata` is edited in place, adding `adata.uns[&#34;{}_centroids&#34;]`, 
    `adata.uns[&#34;{}_centroid_distances&#34;]`, and `adata.uns[&#34;{}_centroid_MST&#34;]` 
    containing centroid coordinates, distance matrix between all centoids, and a 
    minimum spanning tree graph between the centroids, respectively
    &#34;&#34;&#34;
    # calculate centroids
    clu_names = adata.obs[obs_col].unique().astype(str)
    if use_rep == &#34;X&#34;:
        adata.uns[&#34;{}_centroids&#34;.format(use_rep)] = np.array(
            [
                np.mean(adata.X[adata.obs[obs_col].astype(str) == clu, :], axis=0)
                for clu in clu_names
            ]
        )
    else:
        adata.uns[&#34;{}_centroids&#34;.format(use_rep)] = np.array(
            [
                np.mean(
                    adata.obsm[use_rep][adata.obs[obs_col].astype(str) == clu, :],
                    axis=0,
                )
                for clu in clu_names
            ]
        )
    # calculate distances between all centroids
    adata.uns[&#34;{}_centroid_distances&#34;.format(use_rep)] = cdist(
        adata.uns[&#34;{}_centroids&#34;.format(use_rep)],
        adata.uns[&#34;{}_centroids&#34;.format(use_rep)],
    )
    # build networkx minimum spanning tree between centroids
    G = nx.from_numpy_matrix(adata.uns[&#34;{}_centroid_distances&#34;.format(use_rep)])
    G = nx.relabel_nodes(G, mapping=dict(zip(list(G.nodes), clu_names)), copy=True)
    adata.uns[&#34;{}_centroid_MST&#34;.format(use_rep)] = nx.minimum_spanning_tree(G)


# dimensionality reduction plotting class #
class DR_plot:
    &#34;&#34;&#34;
    Class defining pretty plots of dimension-reduced embeddings such as PCA, t-SNE, 
    and UMAP

    Attributes
    ----------

    .fig : matplotlib.figure
        the figure object on which data will be plotted
    .ax : matplotlib.axes.ax
        the axes within `self.fig`
    .cmap : matplotlib.pyplot.cmap
        color map to use for plotting; default=&#34;plasma&#34;

    Methods
    -------

    .plot()
        utility plotting function that can be passed any numpy array in the `data` 
        parameter
    .plot_IDs()
        plots one or more cluster IDs on top of an `.obsm` from an AnnData object
    .plot_centroids()
        plots cluster centroids defined using `find_centroids()` function on AnnData 
        object
    &#34;&#34;&#34;

    def __init__(self, dim_name=&#34;dim&#34;, figsize=(5, 5), ax_labels=True):
        &#34;&#34;&#34;
        Initializes `DR_plot` class

        Parameters
        ----------

        dim_name : str, optional (default=&#34;dim&#34;)
            how to label axes (&#34;dim 1&#34; on x and &#34;dim 2&#34; on y by default)
        figsize : tuple of float, optional (default=(5,5))
            size of resulting figure in inches
        ax_labels : bool, optional (default=True)
            draw arrows and dimension names in lower left corner of plot

        Returns
        -------

        Initializes `self.fig` and `self.ax` according to input specs
        &#34;&#34;&#34;
        self.fig, self.ax = plt.subplots(1, figsize=figsize)
        self.cmap = plt.get_cmap(&#34;plasma&#34;)

        if ax_labels:
            plt.xlabel(&#34;{} 1&#34;.format(dim_name), fontsize=14)
            self.ax.xaxis.set_label_coords(0.2, -0.025)
            plt.ylabel(&#34;{} 2&#34;.format(dim_name), fontsize=14)
            self.ax.yaxis.set_label_coords(-0.025, 0.2)

            plt.annotate(
                &#34;&#34;,
                textcoords=&#34;axes fraction&#34;,
                xycoords=&#34;axes fraction&#34;,
                xy=(-0.006, 0),
                xytext=(0.2, 0),
                arrowprops=dict(arrowstyle=&#34;&lt;-&#34;, lw=2, color=&#34;black&#34;),
            )
            plt.annotate(
                &#34;&#34;,
                textcoords=&#34;axes fraction&#34;,
                xycoords=&#34;axes fraction&#34;,
                xy=(0, -0.006),
                xytext=(0, 0.2),
                arrowprops=dict(arrowstyle=&#34;&lt;-&#34;, lw=2, color=&#34;black&#34;),
            )

        plt.tick_params(labelbottom=False, labelleft=False)
        sns.despine(left=True, bottom=True)
        plt.tight_layout()

    def plot(self, data, color, pt_size=75, legend=None, save_to=None):
        &#34;&#34;&#34;
        General plotting function for dimensionality reduction outputs with cute 
        arrows and labels

        Parameters
        ----------

        data : np.array
            array containing variables in columns and observations in rows
        color : list
            list of length `nrow(data)` to determine how points should be colored (ie. 
            `adata.obs[&#34;leiden&#34;].values` to color by &#34;leiden&#34; cluster categories)
        pt_size : float, optional (default=75)
            size of points in plot
        legend : str {&#34;full&#34;,&#34;brief&#34;}, optional (default=None)
            string describing the legend size. None for no legend
        save_to : str, optional (default=None)
            path to `.png` file to save output. do not save if None

        Returns
        -------

        `self.fig`, `self.ax` edited; plot saved to `.png` file if `save_to` is not 
        None
        &#34;&#34;&#34;
        sns.scatterplot(
            x=data[:, 0],
            y=data[:, 1],
            s=pt_size,
            alpha=0.7,
            hue=color,
            legend=legend,
            edgecolor=&#34;none&#34;,
            ax=self.ax,
        )

        if legend is not None:
            plt.legend(
                bbox_to_anchor=(1, 1, 0.2, 0.2),
                loc=&#34;lower left&#34;,
                frameon=False,
                fontsize=&#34;small&#34;,
            )

        if save_to is None:
            return
        else:
            plt.savefig(fname=save_to, transparent=True, bbox_inches=&#34;tight&#34;, dpi=1000)

    def plot_IDs(
        self, adata, use_rep, obs_col=&#34;leiden&#34;, IDs=&#34;all&#34;, pt_size=75, save_to=None
    ):
        &#34;&#34;&#34;
        General plotting function for dimensionality reduction outputs with 
        categorical colors (i.e. &#34;leiden&#34; or &#34;louvain&#34;) and cute arrows and labels

        Parameters
        ----------

        adata : anndata.AnnData
            object to pull dimensionality reduction from
        use_rep : str
            `adata.obsm` key to plot from (i.e. &#34;X_pca&#34;)
        obs_col : str, optional (default=&#34;leiden&#34;)
            name of column in `adata.obs` to use as cell IDs (i.e. &#34;leiden&#34;)
        IDs : list of str, optional (default=&#34;all&#34;)
            list of IDs to plot, graying out cells not assigned to those IDs. if 
            &#34;all&#34;, show all ID categories.
        pt_size : float, optional (default=75)
            size of points in plot
        save_to : str, optional (default=None)
            path to `.png` file to save output. do not save if None

        Returns
        -------

        `self.fig`, `self.ax` edited; plot saved to `.png` file if `save_to` is not 
        None
        &#34;&#34;&#34;
        plotter = adata.obsm[use_rep]
        clu_names = adata.obs[obs_col].unique().astype(str)

        # use existing scanpy colors, if applicable
        if obs_col == &#34;leiden&#34; and &#34;leiden_colors&#34; in adata.uns.keys():
            colors = [
                adata.uns[&#34;leiden_colors&#34;][x]
                for x in adata.obs.leiden.unique().astype(int)
            ]
        elif obs_col == &#34;louvain&#34; and &#34;louvain_colors&#34; in adata.uns.keys():
            colors = [
                adata.uns[&#34;louvain_colors&#34;][x]
                for x in adata.obs.louvain.unique().astype(int)
            ]
        # otherwise, get new color mapping from obs_col using self.cmap
        else:
            colors = self.cmap(np.linspace(0, 1, len(clu_names)))

        cdict = dict(zip(clu_names, colors))

        if IDs == &#34;all&#34;:
            self.ax.scatter(
                x=plotter[:, 0],
                y=plotter[:, 1],
                s=pt_size,
                alpha=0.7,
                c=[cdict[x] for x in adata.obs[obs_col].astype(str)],
                edgecolor=&#34;none&#34;,
            )

        else:
            sns.scatterplot(
                x=plotter[-adata.obs[obs_col].isin(IDs), 0],
                y=plotter[-adata.obs[obs_col].isin(IDs), 1],
                ax=self.ax,
                s=pt_size,
                alpha=0.1,
                color=&#34;gray&#34;,
                legend=False,
                edgecolor=&#34;none&#34;,
            )
            plt.scatter(
                x=plotter[adata.obs[obs_col].isin(IDs), 0],
                y=plotter[adata.obs[obs_col].isin(IDs), 1],
                s=pt_size,
                alpha=0.7,
                c=[
                    cdict[x]
                    for x in adata.obs.loc[
                        adata.obs[obs_col].isin(IDs), obs_col
                    ].astype(str)
                ],
                edgecolor=&#34;none&#34;,
            )

        if save_to is None:
            return
        else:
            plt.savefig(fname=save_to, transparent=True, bbox_inches=&#34;tight&#34;, dpi=1000)

    def plot_centroids(
        self,
        adata,
        use_rep,
        obs_col=&#34;leiden&#34;,
        ctr_size=300,
        pt_size=75,
        draw_edges=True,
        highlight_edges=False,
        save_to=None,
    ):
        &#34;&#34;&#34;
        General plotting function for cluster centroid graph and MST 
        (i.e. from &#34;leiden&#34; or &#34;louvain&#34;) and cute arrows and labels

        Parameters
        ----------

        adata : anndata.AnnData
            object to pull dimensionality reduction from
        use_rep : str
            `adata.obsm` key to plot from (i.e. &#34;X_pca&#34;)
        obs_col : str, optional (default=&#34;leiden&#34;)
            name of column in `adata.obs` to use as cell IDs (i.e. &#34;leiden&#34;)
        ctr_size : float, optional (default=300)
            size of centroid points in plot
        pt_size : float, optional (default=75)
            size of points in plot
        draw_edges : bool, optional (default=True)
            draw edges of minimum spanning tree between all centroids
        highlight_edges : list of int, optional (default=False)
            list of edge IDs as tuples to highlight in red on plot. e.g. 
            `set(adata.uns[&#39;X_tsne_centroid_MST&#39;].edges).difference(set(adata.uns[&#39;X_umap_centroid_MST&#39;].edges))`
            with output {(0,3), (0,7)} says that edges from centroid 0 to 3 and 0 to 7 
            are found in &#39;X_tsne_centroids&#39; but not in &#39;X_umap_centroids&#39;. highlight 
            the edges to show this.
        save_to : str, optional (default=None)
            path to `.png` file to save output. do not save if None

        Returns
        -------

        `self.fig`, `self.ax` edited; plot saved to `.png` file if `save_to` is not 
        None
        &#34;&#34;&#34;
        clu_names = adata.obs[obs_col].unique().astype(str)
        # use existing scanpy colors, if applicable
        if obs_col == &#34;leiden&#34; and &#34;leiden_colors&#34; in adata.uns.keys():
            colors = [
                adata.uns[&#34;leiden_colors&#34;][x]
                for x in adata.obs.leiden.unique().astype(int)
            ]
        elif obs_col == &#34;louvain&#34; and &#34;louvain_colors&#34; in adata.uns.keys():
            colors = [
                adata.uns[&#34;louvain_colors&#34;][x]
                for x in adata.obs.louvain.unique().astype(int)
            ]
        # otherwise, get new color mapping from obs_col using self.cmap
        else:
            colors = self.cmap(np.linspace(0, 1, len(clu_names)))

        # draw points in embedding first
        sns.scatterplot(
            x=adata.obsm[use_rep][:, 0],
            y=adata.obsm[use_rep][:, 1],
            ax=self.ax,
            s=pt_size,
            alpha=0.1,
            color=&#34;gray&#34;,
            legend=False,
            edgecolor=&#34;none&#34;,
        )

        # draw MST edges if desired, otherwise just draw centroids
        if not draw_edges:
            self.ax.scatter(
                x=adata.uns[&#34;{}_centroids&#34;.format(use_rep)][:, 0],
                y=adata.uns[&#34;{}_centroids&#34;.format(use_rep)][:, 1],
                s=ctr_size,
                c=colors,
                edgecolor=&#34;none&#34;,
            )
        else:
            pos = dict(zip(clu_names, adata.uns[&#34;{}_centroids&#34;.format(use_rep)][:, :2]))
            nx.draw_networkx(
                adata.uns[&#34;{}_centroid_MST&#34;.format(use_rep)],
                pos=pos,
                ax=self.ax,
                with_labels=False,
                width=2,
                node_size=ctr_size,
                node_color=colors,
            )
            # highlight edges if desired
            if highlight_edges:
                nx.draw_networkx_edges(
                    adata.uns[&#34;{}_centroid_MST&#34;.format(use_rep)],
                    pos=pos,
                    ax=self.ax,
                    edgelist=highlight_edges,
                    width=5,
                    edge_color=&#34;red&#34;,
                )

        if save_to is None:
            return
        else:
            plt.savefig(fname=save_to, transparent=True, bbox_inches=&#34;tight&#34;, dpi=1000)



def distance_stats(pre, post, downsample=False, verbose=True):
    &#34;&#34;&#34;
    Tests for correlation between Euclidean cell-cell distances before and after 
    transformation by a function or DR algorithm.

    Parameters
    ----------

    pre : np.array
        vector of unique distances (pdist()) or distance matrix of shape (n_cells, 
        m_cells), i.e. (cdist()) before transformation/projection
    post : np.array
        vector of unique distances (pdist()) or distance matrix of shape (n_cells, 
        m_cells), i.e. (cdist()) after transformation/projection
    downsample : int, optional (default=False)
        number of distances to downsample to. maximum of 50M (~10k cells, if 
        symmetrical) is recommended for performance.
    verbose : bool, optional (default=True)
        print progress statements to console

    Returns
    -------

    pre : np.array
        vector of normalized unique distances (pdist()) or distance matrix of shape 
        (n_cells, m_cells), before transformation/projection
    post : np.array
        vector of normalized unique distances (pdist()) or distance matrix of shape 
        (n_cells, m_cells), after transformation/projection
    corr_stats : list
        output of `pearsonr()` function correlating the two normalized unique distance 
        vectors
    EMD : float
        output of `wasserstein_1d()` function calculating the Earth Mover&#39;s Distance 
        between the two normalized unique distance vectors

    1) performs Pearson correlation of distance distributions
    2) normalizes unique distances using min-max standardization for each dataset
    3) calculates Wasserstein or Earth-Mover&#39;s Distance for normalized distance 
    distributions between datasets
    &#34;&#34;&#34;
    # make sure the number of cells in each matrix is the same
    assert (
        pre.shape == post.shape
    ), &#39;Matrices contain different number of distances.\n{} in &#34;pre&#34;\n{} in &#34;post&#34;\n&#39;.format(
        pre.shape[0], post.shape[0]
    )

    # if distance matrix (mA x mB, result of cdist), flatten to unique cell-cell distances
    if pre.ndim == 2:
        if verbose:
            print(&#34;Flattening pre-transformation distance matrix into 1D array...&#34;)
        # if symmetric, only keep unique values (above diagonal)
        if np.allclose(pre, pre.T, rtol=1e-05, atol=1e-08):
            pre = pre[np.triu_indices(n=pre.shape[0], k=1)]
        # otherwise, flatten all distances
        else:
            pre = pre.flatten()

    # if distance matrix (mA x mB, result of cdist), flatten to unique cell-cell distances
    if post.ndim == 2:
        if verbose:
            print(&#34;Flattening post-transformation distance matrix into 1D array...&#34;)
        # if symmetric, only keep unique values (above diagonal)
        if np.allclose(post, post.T, rtol=1e-05, atol=1e-08):
            post = post[np.triu_indices(n=post.shape[0], k=1)]
        # otherwise, flatten all distances
        else:
            post = post.flatten()

    # if dataset is large, randomly downsample to reasonable number of distances for calculation
    if downsample:
        assert downsample &lt; len(
            pre
        ), &#34;Must provide downsample value smaller than total number of cell-cell distances provided in pre and post&#34;
        if verbose:
            print(&#34;Downsampling to {} total cell-cell distances...&#34;.format(downsample))
        idx = np.random.choice(np.arange(len(pre)), downsample, replace=False)
        pre = pre[idx]
        post = post[idx]

    # calculate correlation coefficient using Pearson correlation
    if verbose:
        print(&#34;Correlating distances&#34;)
    corr_stats = pearsonr(x=pre, y=post)

    # min-max normalization for fair comparison of probability distributions
    if verbose:
        print(&#34;Normalizing unique distances&#34;)
    pre -= pre.min()
    pre /= pre.ptp()

    post -= post.min()
    post /= post.ptp()

    # calculate EMD for the distance matrices
    # by default, downsample to 50M distances to speed processing time,
    # since this function often breaks with larger distributions
    if verbose:
        print(&#34;Calculating Earth-Mover&#39;s Distance between distributions&#34;)
    if len(pre) &gt; 50000000:
        idx = np.random.choice(np.arange(len(pre)), 50000000, replace=False)
        pre_EMD = pre[idx]
        post_EMD = post[idx]
        EMD = wasserstein_1d(pre_EMD, post_EMD)
    else:
        EMD = wasserstein_1d(pre, post)

    return pre, post, corr_stats, EMD


def knn_preservation(pre, post):
    &#34;&#34;&#34;
    Tests for k-nearest neighbor preservation (%) before and after transformation by a 
    function or DR algorithm.

    Parameters
    ----------

    pre : np.array
        knn graph of shape (n_cells, n_cells) before transformation/projection
    post : np.array
        knn graph of shape (n_cells, n_cells) after transformation/projection

    Returns
    -------

    knn_pres : float
        knn preservation expressed as a percentage out of 100 %
    &#34;&#34;&#34;
    # make sure the number of cells in each matrix is the same
    assert (
        pre.shape == post.shape
    ), &#39;Matrices contain different number of cells.\n{} in &#34;pre&#34;\n{} in &#34;post&#34;\n&#39;.format(
        pre.shape[0], post.shape[0]
    )
    return np.round(
        (np.isclose(pre, post, rtol=1e-05, atol=1e-08).sum() / (pre.shape[0] ** 2))
        * 100,
        4,
    )


def structure_preservation_sc(
    adata,
    latent,
    native=&#34;X&#34;,
    metric=&#34;euclidean&#34;,
    k=30,
    downsample=False,
    verbose=True,
    force_recalc=False,
):
    &#34;&#34;&#34;
    Wrapper function for full structural preservation workflow applied to `scanpy` 
    AnnData object

    Parameters
    ----------

    adata : anndata.AnnData
        AnnData object with latent space to test in `.obsm` slot, and native 
        (reference) space in `.X` or `.obsm`
    latent : str
        `adata.obsm` key that contains low-dimensional latent space for testing
    native : str, optional (default=&#34;X&#34;)
        `adata.obsm` key or `.X` containing high-dimensional native space, which 
        should be direct input to dimension reduction that generated latent `.obsm` 
        for fair comparison. default &#34;X&#34;, which uses `adata.X`.
    metric : str {&#34;chebyshev&#34;,&#34;cityblock&#34;,&#34;euclidean&#34;,&#34;minkowski&#34;,&#34;mahalanobis&#34;,
    &#34;seuclidean&#34;}, optional (default=&#34;euclidean&#34;)
        distance metric to use
    k : int, optional (default=30)
        number of nearest neighbors to test preservation
    downsample : int, optional (default=False)
        number of distances to downsample to. maximum of 50M (~10k cells, if 
        symmetrical) is recommended for performance.
    verbose : bool, optional (default=True)
        print progress statements to console
    force_recalc : bool, optional (default=False)
        if True, recalculate all distances and neighbor graphs, regardless of their 
        presence in `adata`

    Returns
    -------

    corr_stats : list
        output of `pearsonr()` function correlating the two normalized unique distance 
        vectors
    EMD : float
        output of `wasserstein_1d()` function calculating the Earth Mover&#39;s Distance 
        between the two normalized unique distance vectors
    knn_pres : float
        knn preservation expressed as a percentage out of 100 %
    &#34;&#34;&#34;
    # 0) determine native space according to argument
    if native == &#34;X&#34;:
        native_space = adata.X.copy()
    else:
        native_space = adata.obsm[native].copy()

    # 1) calculate unique cell-cell distances
    if (
        &#34;{}_distances&#34;.format(native) not in adata.uns.keys() or force_recalc
    ):  # check for existence in AnnData to prevent re-work
        if verbose:
            print(&#34;Calculating unique distances for native space, {}&#34;.format(native))
        adata.uns[&#34;{}_distances&#34;.format(native)] = cdist(
            native_space, native_space, metric=metric
        )

    if (
        &#34;{}_distances&#34;.format(latent) not in adata.uns.keys() or force_recalc
    ):  # check for existence in AnnData to prevent re-work
        if verbose:
            print(&#34;Calculating unique distances for latent space, {}&#34;.format(latent))
        adata.uns[&#34;{}_distances&#34;.format(latent)] = cdist(
            adata.obsm[latent], adata.obsm[latent], metric=metric
        )

    # 2) get correlation and EMD values, and return normalized distance vectors for plotting distributions
    (
        adata.uns[&#34;{}_norm_distances&#34;.format(native)],
        adata.uns[&#34;{}_norm_distances&#34;.format(latent)],
        corr_stats,
        EMD,
    ) = distance_stats(
        pre=adata.uns[&#34;{}_distances&#34;.format(native)].copy(),
        post=adata.uns[&#34;{}_distances&#34;.format(latent)].copy(),
        verbose=verbose,
        downsample=downsample,
    )

    # 3) determine neighbors
    if (
        &#34;{}_neighbors&#34;.format(native) not in adata.uns.keys() or force_recalc
    ):  # check for existence in AnnData to prevent re-work
        if verbose:
            print(
                &#34;{}-nearest neighbor calculation for native space, {}&#34;.format(k, native)
            )
        knn_graph(
            adata.uns[&#34;{}_distances&#34;.format(native)],
            k=k,
            adata=adata,
            save_rep=&#34;{}_knn&#34;.format(native),
        )

    if (
        &#34;{}_neighbors&#34;.format(latent) not in adata.uns.keys() or force_recalc
    ):  # check for existence in AnnData to prevent re-work
        if verbose:
            print(
                &#34;{}-nearest neighbor calculation for latent space, {}&#34;.format(k, latent)
            )
        knn_graph(
            adata.uns[&#34;{}_distances&#34;.format(latent)],
            k=k,
            adata=adata,
            save_rep=&#34;{}_knn&#34;.format(latent),
        )

    # 4) calculate neighbor preservation
    if verbose:
        print(&#34;Determining nearest neighbor preservation&#34;)
    if (
        adata.uns[&#34;{}_knn&#34;.format(native)][&#34;k&#34;]
        != adata.uns[&#34;{}_knn&#34;.format(latent)][&#34;k&#34;]
    ):
        warnings.warn(
            &#39;Warning: Nearest-neighbor graphs constructed with different k values. k={} in &#34;{}_neighbors&#34;, while k={} in &#34;{}_neighbors&#34;. Consider re-generating neighbors graphs by setting force_recalc=True.&#39;.format(
                adata.uns[&#34;{}_knn&#34;.format(native)][&#34;k&#34;],
                native,
                adata.uns[&#34;{}_knn&#34;.format(latent)][&#34;k&#34;],
                latent,
            )
        )
    knn_pres = knn_preservation(
        pre=adata.uns[&#34;{}_knn&#34;.format(native)][&#34;graph&#34;],
        post=adata.uns[&#34;{}_knn&#34;.format(latent)][&#34;graph&#34;],
    )

    if verbose:
        print(&#34;Done!&#34;)
    return corr_stats, EMD, knn_pres



class SP_plot:
    &#34;&#34;&#34;
    Class defining pretty plots for structural evaluation of dimension-reduced 
    embeddings such as PCA, t-SNE, and UMAP

    Attributes
    ----------

    .figsize : tuple of float
        the size of the figure object on which data will be plotted
    .fig : matplotlib.figure
        the figure object on which data will be plotted
    .ax : matplotlib.axes.ax
        the axes within `self.fig`
    .palette : sns.cubehelix_palette()
        color palette to use for coloring `seaborn` plots
    .cmap : matplotlib.pyplot.cmap
        color map to use for plotting; default=&#34;cubehelix&#34; from `seaborn`
    .pre : np.array
        flattened vector of normalized, unique cell-cell distances 
        &#34;pre-transformation&#34;. upper triangle of cell-cell distance matrix, flattened 
        to vector of shape ((n_cells^2)/2)-n_cells.
    .post : np.array
        flattened vector of normalized, unique cell-cell distances 
        &#34;post-transformation&#34;. upper triangle of cell-cell distance matrix, flattened 
        to vector of shape ((n_cells^2)/2)-n_cells.
    .labels : list of str
        name of pre- and post-transformation spaces for legend (plot_cell_distances, 
        plot_distributions, plot_cumulative_distributions) or axis labels 
        (plot_distance_correlation, joint_plot_distance_correlation) as list of two 
        strings. False to exclude labels.

    Methods
    -------

    .plot_cell_distances()
        plots all unique cell-cell distances before and after some transformation
    .plot_distributions()
        plots probability distributions for all unique cell-cell distances before and 
        after some transformation
    .plot_cumulative_distributions()
        plots cumulative probability distributions for all unique cell-cell distances 
        before and after some transformation
    .plot_distance_correlation()
        plots correlation of all unique cell-cell distances before and after some 
        transformation
    .joint_plot_distance_correlation()
        plots correlation of all unique cell-cell distances before and after some 
        transformation. includes marginal plots of each distribution.
    &#34;&#34;&#34;

    def __init__(
        self, pre_norm, post_norm, figsize=(4, 4), labels=[&#34;Native&#34;, &#34;Latent&#34;]
    ):
        &#34;&#34;&#34;
        Initializes SP plot class

        Parameters
        ----------

        pre_norm : np.array
            flattened vector of normalized, unique cell-cell distances 
            &#34;pre-transformation&#34;. upper triangle of cell-cell distance matrix, flattened 
            to vector of shape ((n_cells^2)/2)-n_cells.
        post_norm : np.array
            flattened vector of normalized, unique cell-cell distances 
            &#34;post-transformation&#34;. upper triangle of cell-cell distance matrix, flattened 
            to vector of shape ((n_cells^2)/2)-n_cells.
        figsize : tuple of float, optional (default=(4,4))
            the size of the figure object on which data will be plotted
        labels : list of str, optional (default=[&#34;Native&#34;,&#34;Latent&#34;])
            name of pre- and post-transformation spaces for legend (plot_cell_distances, 
            plot_distributions, plot_cumulative_distributions) or axis labels 
            (plot_distance_correlation, joint_plot_distance_correlation) as list of two 
            strings. False to exclude labels.

        Returns
        -------

        Initializes `self.fig` and `self.ax` according to input specs
        &#34;&#34;&#34;
        self.figsize = figsize
        self.fig, self.ax = plt.subplots(1, figsize=self.figsize)
        self.palette = sns.cubehelix_palette()
        self.cmap = sns.cubehelix_palette(as_cmap=True)
        self.pre = pre_norm
        self.post = post_norm
        self.labels = labels

        plt.tick_params(labelbottom=False, labelleft=False)
        sns.despine()
        plt.tight_layout()

    def plot_cell_distances(self, legend=True, save_to=None):
        &#34;&#34;&#34;
        Plots all unique cell-cell distances before and after some transformation

        Parameters
        ----------

        legend : bool, optional (default=True)
            display legend on plot
        save_to : str, optional (default=None)
            path to `.png` file to save output. do not save if None

        Returns
        -------

        `self.fig`, `self.ax` edited; plot saved to `.png` file if `save_to` is not 
        None
        &#34;&#34;&#34;
        plt.plot(self.pre, alpha=0.7, label=self.labels[0], color=self.palette[-1])
        plt.plot(self.post, alpha=0.7, label=self.labels[1], color=self.palette[2])
        if legend:
            plt.legend(loc=&#34;best&#34;, fontsize=&#34;xx-large&#34;)
        else:
            plt.legend()
            self.ax.legend().remove()

        if save_to is None:
            return
        else:
            plt.savefig(fname=save_to, transparent=True, bbox_inches=&#34;tight&#34;, dpi=1000)

    def plot_distributions(self, legend=True, save_to=None):
        &#34;&#34;&#34;
        Plots probability distributions for all unique cell-cell distances before and 
        after some transformation

        Parameters
        ----------

        legend : bool, optional (default=True)
            display legend on plot
        save_to : str, optional (default=None)
            path to `.png` file to save output. do not save if None

        Returns
        -------

        `self.fig`, `self.ax` edited; plot saved to `.png` file if `save_to` is not 
        None
        &#34;&#34;&#34;
        sns.distplot(
            self.pre, hist=False, kde=True, label=self.labels[0], color=self.palette[-1]
        )
        sns.distplot(
            self.post, hist=False, kde=True, label=self.labels[1], color=self.palette[2]
        )
        if legend:
            plt.legend(loc=&#34;best&#34;, fontsize=&#34;xx-large&#34;)
        else:
            plt.legend()
            self.ax.legend().remove()

        if save_to is None:
            return
        else:
            plt.savefig(fname=save_to, transparent=True, bbox_inches=&#34;tight&#34;, dpi=1000)

    def plot_cumulative_distributions(self, legend=True, save_to=None):
        &#34;&#34;&#34;
        Plots cumulative probability distributions for all unique cell-cell distances 
        before and after some transformation

        Parameters
        ----------

        legend : bool, optional (default=True)
            display legend on plot
        save_to : str, optional (default=None)
            path to `.png` file to save output. do not save if None

        Returns
        -------

        `self.fig`, `self.ax` edited; plot saved to `.png` file if `save_to` is not 
        None
        &#34;&#34;&#34;
        num_bins = int(len(self.pre) / 100)
        pre_counts, pre_bin_edges = np.histogram(self.pre, bins=num_bins)
        pre_cdf = np.cumsum(pre_counts)
        post_counts, post_bin_edges = np.histogram(self.post, bins=num_bins)
        post_cdf = np.cumsum(post_counts)
        plt.plot(
            pre_bin_edges[1:],
            pre_cdf / pre_cdf[-1],
            label=self.labels[0],
            color=self.palette[-1],
        )
        plt.plot(
            post_bin_edges[1:],
            post_cdf / post_cdf[-1],
            label=self.labels[1],
            color=self.palette[2],
        )
        if legend:
            plt.legend(loc=&#34;lower right&#34;, fontsize=&#34;xx-large&#34;)
        else:
            plt.legend()
            self.ax.legend().remove()

        if save_to is None:
            return
        else:
            plt.savefig(fname=save_to, transparent=True, bbox_inches=&#34;tight&#34;, dpi=1000)

    def plot_distance_correlation(self, save_to=None):
        &#34;&#34;&#34;
        Plots correlation of all unique cell-cell distances before and after some 
        transformation

        Parameters
        ----------

        save_to : str, optional (default=None)
            path to `.png` file to save output. do not save if None

        Returns
        -------

        `self.fig`, `self.ax` edited; plot saved to `.png` file if `save_to` is not 
        None
        &#34;&#34;&#34;
        plt.hist2d(x=self.pre, y=self.post, bins=50, cmap=self.cmap)
        plt.plot(
            np.linspace(max(min(self.pre), min(self.post)), 1, 100),
            np.linspace(max(min(self.pre), min(self.post)), 1, 100),
            linestyle=&#34;dashed&#34;,
            color=self.palette[-1],
        )  # plot identity line as reference for regression
        if self.labels:
            plt.xlabel(self.labels[0], fontsize=&#34;xx-large&#34;, color=self.palette[-1])
            plt.ylabel(self.labels[1], fontsize=&#34;xx-large&#34;, color=self.palette[2])

        if save_to is None:
            return
        else:
            plt.savefig(fname=save_to, transparent=True, bbox_inches=&#34;tight&#34;, dpi=1000)

    def joint_plot_distance_correlation(self, save_to=None):
        &#34;&#34;&#34;
        Plots correlation of all unique cell-cell distances before and after some 
        transformation. includes marginal plots of each distribution.

        Parameters
        ----------

        save_to : str, optional (default=None)
            path to `.png` file to save output. do not save if None

        Returns
        -------

        `self.fig`, `self.ax` edited; plot saved to `.png` file if `save_to` is not 
        None
        &#34;&#34;&#34;
        plt.close()  # close matplotlib figure from __init__() and start over with seaborn.JointGrid()
        self.fig = sns.JointGrid(
            x=self.pre, y=self.post, space=0, height=self.figsize[0]
        )
        self.fig.plot_joint(plt.hist2d, bins=50, cmap=self.cmap)
        sns.kdeplot(
            x=self.pre,
            color=self.palette[-1],
            shade=False,
            bw_method=0.01,
            ax=self.fig.ax_marg_x,
        )
        sns.kdeplot(
            y=self.post,
            color=self.palette[2],
            shade=False,
            bw_method=0.01,
            ax=self.fig.ax_marg_y,
        )
        self.fig.ax_joint.plot(
            np.linspace(max(min(self.pre), min(self.post)), 1, 100),
            np.linspace(max(min(self.pre), min(self.post)), 1, 100),
            linestyle=&#34;dashed&#34;,
            color=self.palette[-1],
        )  # plot identity line as reference for regression
        if self.labels:
            plt.xlabel(self.labels[0], fontsize=&#34;xx-large&#34;, color=self.palette[-1])
            plt.ylabel(self.labels[1], fontsize=&#34;xx-large&#34;, color=self.palette[2])

        plt.tick_params(labelbottom=False, labelleft=False)

        if save_to is None:
            return
        else:
            plt.savefig(fname=save_to, transparent=True, bbox_inches=&#34;tight&#34;, dpi=1000)



def cluster_arrangement_sc(
    adata,
    pre,
    post,
    obs_col,
    IDs,
    ID_names=None,
    figsize=(4, 4),
    legend=True,
    ax_labels=[&#34;Native&#34;, &#34;Latent&#34;],
):
    &#34;&#34;&#34;
    Determines pairwise distance preservation between 3 IDs from `adata.obs[obs_col]`

    Parameters
    ----------

    adata : anndata.AnnData
        anndata object to pull dimensionality reduction from
    pre : np.array
        matrix to subset as pre-transformation (i.e. `adata.X`)
    post : np.array
        matrix to subset as pre-transformation (i.e. `adata.obsm[&#34;X_pca&#34;]`)
    obs_col : str
        name of column in `adata.obs` to use as cell IDs (i.e. &#34;louvain&#34;)
    IDs : list of int (len==3)
        list of THREE ID indices to compare (i.e. [0,1,2])
    figsize : tuple of float, optional (default=(4,4))
        size of resulting figure
    legend : bool, optional (default=True)
        display legend on plot
    ax_labels : list of str (len==2), optional (default=[&#34;Native&#34;,&#34;Latent&#34;])
        list of two strings for x and y axis labels, respectively. if False, exclude 
        axis labels.

    Returns
    -------

    corr_stats : list
        list of outputs of `pearsonr()` function correlating the three normalized 
        unique distance vectors in a pairwise fashion
    EMD : float
        list of outputs of `wasserstein_1d()` function calculating the Earth Mover&#39;s 
        Distance between the three normalized unique distance vectors in a pairwise 
        fashion

    Outputs jointplot with scatter of pairwise distance correlations, with marginal 
    KDE plots showing density of each native and latent distance vector
    &#34;&#34;&#34;
    # distance calculations for pre_obj
    dist_0_1 = cdist(
        pre[adata.obs[obs_col] == IDs[0]], pre[adata.obs[obs_col] == IDs[1]]
    ).flatten()
    dist_0_2 = cdist(
        pre[adata.obs[obs_col] == IDs[0]], pre[adata.obs[obs_col] == IDs[2]]
    ).flatten()
    dist_1_2 = cdist(
        pre[adata.obs[obs_col] == IDs[1]], pre[adata.obs[obs_col] == IDs[2]]
    ).flatten()
    # combine and min-max normalize
    dist = np.append(np.append(dist_0_1, dist_0_2), dist_1_2)
    dist -= dist.min()
    dist /= dist.ptp()
    # split normalized distances by cluster pair
    dist_norm_0_1 = dist[: dist_0_1.shape[0]]
    dist_norm_0_2 = dist[dist_0_1.shape[0] : dist_0_1.shape[0] + dist_0_2.shape[0]]
    dist_norm_1_2 = dist[dist_0_1.shape[0] + dist_0_2.shape[0] :]

    # distance calculations for post_obj
    post_0_1 = cdist(
        post[adata.obs[obs_col] == IDs[0]], post[adata.obs[obs_col] == IDs[1]]
    ).flatten()
    post_0_2 = cdist(
        post[adata.obs[obs_col] == IDs[0]], post[adata.obs[obs_col] == IDs[2]]
    ).flatten()
    post_1_2 = cdist(
        post[adata.obs[obs_col] == IDs[1]], post[adata.obs[obs_col] == IDs[2]]
    ).flatten()
    # combine and min-max normalize
    post = np.append(np.append(post_0_1, post_0_2), post_1_2)
    post -= post.min()
    post /= post.ptp()
    # split normalized distances by cluster pair
    post_norm_0_1 = post[: post_0_1.shape[0]]
    post_norm_0_2 = post[post_0_1.shape[0] : post_0_1.shape[0] + post_0_2.shape[0]]
    post_norm_1_2 = post[post_0_1.shape[0] + post_0_2.shape[0] :]

    # calculate EMD and Pearson correlation stats
    EMD = [
        wasserstein_1d(dist_norm_0_1, post_norm_0_1),
        wasserstein_1d(dist_norm_0_2, post_norm_0_2),
        wasserstein_1d(dist_norm_1_2, post_norm_1_2),
    ]
    corr_stats = [
        pearsonr(x=dist_0_1, y=post_0_1)[0],
        pearsonr(x=dist_0_2, y=post_0_2)[0],
        pearsonr(x=dist_1_2, y=post_1_2)[0],
    ]

    if ID_names is None:
        ID_names = IDs.copy()

    # generate jointplot
    g = sns.JointGrid(x=dist, y=post, space=0, height=figsize[0])
    g.plot_joint(plt.hist2d, bins=50, cmap=sns.cubehelix_palette(as_cmap=True))
    sns.kdeplot(
        dist_norm_0_1,
        shade=False,
        bw_method=0.01,
        ax=g.ax_marg_x,
        color=&#34;darkorange&#34;,
        label=ID_names[0] + &#34; - &#34; + ID_names[1],
        legend=legend,
    )
    sns.kdeplot(
        dist_norm_0_2,
        shade=False,
        bw_method=0.01,
        ax=g.ax_marg_x,
        color=&#34;darkgreen&#34;,
        label=ID_names[0] + &#34; - &#34; + ID_names[2],
        legend=legend,
    )
    sns.kdeplot(
        dist_norm_1_2,
        shade=False,
        bw_method=0.01,
        ax=g.ax_marg_x,
        color=&#34;darkred&#34;,
        label=ID_names[1] + &#34; - &#34; + ID_names[2],
        legend=legend,
    )
    if legend:
        g.ax_marg_x.legend(loc=(1.01, 0.1))

    sns.kdeplot(
        y=post_norm_0_1,
        shade=False,
        bw_method=0.01,
        color=&#34;darkorange&#34;,
        ax=g.ax_marg_y,
    )
    sns.kdeplot(
        y=post_norm_0_2,
        shade=False,
        bw_method=0.01,
        color=&#34;darkgreen&#34;,
        ax=g.ax_marg_y,
    )
    sns.kdeplot(
        y=post_norm_1_2,
        shade=False,
        bw_method=0.01,
        color=&#34;darkred&#34;,
        ax=g.ax_marg_y,
    )
    g.ax_joint.plot(
        np.linspace(max(dist.min(), post.min()), 1, 100),
        np.linspace(max(dist.min(), post.min()), 1, 100),
        linestyle=&#34;dashed&#34;,
        color=sns.cubehelix_palette()[-1],
    )  # plot identity line as reference for regression
    if ax_labels:
        plt.xlabel(ax_labels[0], fontsize=&#34;xx-large&#34;, color=sns.cubehelix_palette()[-1])
        plt.ylabel(ax_labels[1], fontsize=&#34;xx-large&#34;, color=sns.cubehelix_palette()[2])

    plt.tick_params(labelleft=False, labelbottom=False)

    return corr_stats, EMD</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="fcc_utils.arcsinh"><code class="name flex">
<span>def <span class="ident">arcsinh</span></span>(<span>adata, layer=None, norm='l1', scale=1000)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns arcsinh-normalized values for each element in anndata counts matrix</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>adata</code></strong> :&ensp;<code>anndata.AnnData</code></dt>
<dd>AnnData object</dd>
<dt><strong><code>layer</code></strong> :&ensp;<code>str</code>, optional <code>(default=None)</code></dt>
<dd>name of layer to perform arcsinh-normalization on. if None, use <code>adata.X</code></dd>
<dt><strong><code>norm</code></strong> :&ensp;<code>str {"l1","l2"}</code>, optional <code>(default="l1")</code></dt>
<dd>normalization strategy prior to arcsinh transform. None=do not normalize data.
"l1"=divide each count by sum of counts for each cell. "l2"=divide each count
by sqrt of sum of squares of counts for cell.</dd>
<dt><strong><code>scale</code></strong> :&ensp;<code>float</code>, optional <code>(default=1000)</code></dt>
<dd>factor to multiply normalized counts by</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>adata</code> is edited in place to add <code>adata.layers["arcsinh_norm"]</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def arcsinh(adata, layer=None, norm=&#34;l1&#34;, scale=1000):
    &#34;&#34;&#34;
    Returns arcsinh-normalized values for each element in anndata counts matrix

    Parameters
    ----------

    adata : anndata.AnnData
        AnnData object
    layer : str, optional (default=None)
        name of layer to perform arcsinh-normalization on. if None, use `adata.X`
    norm : str {&#34;l1&#34;,&#34;l2&#34;}, optional (default=&#34;l1&#34;)
        normalization strategy prior to arcsinh transform. None=do not normalize data. 
        &#34;l1&#34;=divide each count by sum of counts for each cell. &#34;l2&#34;=divide each count 
        by sqrt of sum of squares of counts for cell.
    scale : float, optional (default=1000)
        factor to multiply normalized counts by

    Returns
    -------

    `adata` is edited in place to add `adata.layers[&#34;arcsinh_norm&#34;]`
    &#34;&#34;&#34;
    if layer is None:
        mat = adata.X
    else:
        mat = adata.layers[layer]

    adata.layers[&#34;arcsinh_norm&#34;] = np.arcsinh(normalize(mat, axis=1, norm=norm) * scale)</code></pre>
</details>
</dd>
<dt id="fcc_utils.cluster_arrangement_sc"><code class="name flex">
<span>def <span class="ident">cluster_arrangement_sc</span></span>(<span>adata, pre, post, obs_col, IDs, ID_names=None, figsize=(4, 4), legend=True, ax_labels=['Native', 'Latent'])</span>
</code></dt>
<dd>
<div class="desc"><p>Determines pairwise distance preservation between 3 IDs from <code>adata.obs[obs_col]</code></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>adata</code></strong> :&ensp;<code>anndata.AnnData</code></dt>
<dd>anndata object to pull dimensionality reduction from</dd>
<dt><strong><code>pre</code></strong> :&ensp;<code>np.array</code></dt>
<dd>matrix to subset as pre-transformation (i.e. <code>adata.X</code>)</dd>
<dt><strong><code>post</code></strong> :&ensp;<code>np.array</code></dt>
<dd>matrix to subset as pre-transformation (i.e. <code>adata.obsm["X_pca"]</code>)</dd>
<dt><strong><code>obs_col</code></strong> :&ensp;<code>str</code></dt>
<dd>name of column in <code>adata.obs</code> to use as cell IDs (i.e. "louvain")</dd>
<dt><strong><code>IDs</code></strong> :&ensp;<code>list</code> of <code>int (len==3)</code></dt>
<dd>list of THREE ID indices to compare (i.e. [0,1,2])</dd>
<dt><strong><code>figsize</code></strong> :&ensp;<code>tuple</code> of <code>float</code>, optional <code>(default=(4,4))</code></dt>
<dd>size of resulting figure</dd>
<dt><strong><code>legend</code></strong> :&ensp;<code>bool</code>, optional <code>(default=True)</code></dt>
<dd>display legend on plot</dd>
<dt><strong><code>ax_labels</code></strong> :&ensp;<code>list</code> of <code>str (len==2)</code>, optional <code>(default=["Native","Latent"])</code></dt>
<dd>list of two strings for x and y axis labels, respectively. if False, exclude
axis labels.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>corr_stats</code></strong> :&ensp;<code>list</code></dt>
<dd>list of outputs of <code>pearsonr()</code> function correlating the three normalized
unique distance vectors in a pairwise fashion</dd>
<dt><strong><code>EMD</code></strong> :&ensp;<code>float</code></dt>
<dd>list of outputs of <code>wasserstein_1d()</code> function calculating the Earth Mover's
Distance between the three normalized unique distance vectors in a pairwise
fashion</dd>
<dt><code>Outputs jointplot with scatter</code> of <code>pairwise distance correlations, with marginal </code></dt>
<dd>&nbsp;</dd>
<dt><code>KDE plots showing density</code> of <code>each native and latent distance vector</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cluster_arrangement_sc(
    adata,
    pre,
    post,
    obs_col,
    IDs,
    ID_names=None,
    figsize=(4, 4),
    legend=True,
    ax_labels=[&#34;Native&#34;, &#34;Latent&#34;],
):
    &#34;&#34;&#34;
    Determines pairwise distance preservation between 3 IDs from `adata.obs[obs_col]`

    Parameters
    ----------

    adata : anndata.AnnData
        anndata object to pull dimensionality reduction from
    pre : np.array
        matrix to subset as pre-transformation (i.e. `adata.X`)
    post : np.array
        matrix to subset as pre-transformation (i.e. `adata.obsm[&#34;X_pca&#34;]`)
    obs_col : str
        name of column in `adata.obs` to use as cell IDs (i.e. &#34;louvain&#34;)
    IDs : list of int (len==3)
        list of THREE ID indices to compare (i.e. [0,1,2])
    figsize : tuple of float, optional (default=(4,4))
        size of resulting figure
    legend : bool, optional (default=True)
        display legend on plot
    ax_labels : list of str (len==2), optional (default=[&#34;Native&#34;,&#34;Latent&#34;])
        list of two strings for x and y axis labels, respectively. if False, exclude 
        axis labels.

    Returns
    -------

    corr_stats : list
        list of outputs of `pearsonr()` function correlating the three normalized 
        unique distance vectors in a pairwise fashion
    EMD : float
        list of outputs of `wasserstein_1d()` function calculating the Earth Mover&#39;s 
        Distance between the three normalized unique distance vectors in a pairwise 
        fashion

    Outputs jointplot with scatter of pairwise distance correlations, with marginal 
    KDE plots showing density of each native and latent distance vector
    &#34;&#34;&#34;
    # distance calculations for pre_obj
    dist_0_1 = cdist(
        pre[adata.obs[obs_col] == IDs[0]], pre[adata.obs[obs_col] == IDs[1]]
    ).flatten()
    dist_0_2 = cdist(
        pre[adata.obs[obs_col] == IDs[0]], pre[adata.obs[obs_col] == IDs[2]]
    ).flatten()
    dist_1_2 = cdist(
        pre[adata.obs[obs_col] == IDs[1]], pre[adata.obs[obs_col] == IDs[2]]
    ).flatten()
    # combine and min-max normalize
    dist = np.append(np.append(dist_0_1, dist_0_2), dist_1_2)
    dist -= dist.min()
    dist /= dist.ptp()
    # split normalized distances by cluster pair
    dist_norm_0_1 = dist[: dist_0_1.shape[0]]
    dist_norm_0_2 = dist[dist_0_1.shape[0] : dist_0_1.shape[0] + dist_0_2.shape[0]]
    dist_norm_1_2 = dist[dist_0_1.shape[0] + dist_0_2.shape[0] :]

    # distance calculations for post_obj
    post_0_1 = cdist(
        post[adata.obs[obs_col] == IDs[0]], post[adata.obs[obs_col] == IDs[1]]
    ).flatten()
    post_0_2 = cdist(
        post[adata.obs[obs_col] == IDs[0]], post[adata.obs[obs_col] == IDs[2]]
    ).flatten()
    post_1_2 = cdist(
        post[adata.obs[obs_col] == IDs[1]], post[adata.obs[obs_col] == IDs[2]]
    ).flatten()
    # combine and min-max normalize
    post = np.append(np.append(post_0_1, post_0_2), post_1_2)
    post -= post.min()
    post /= post.ptp()
    # split normalized distances by cluster pair
    post_norm_0_1 = post[: post_0_1.shape[0]]
    post_norm_0_2 = post[post_0_1.shape[0] : post_0_1.shape[0] + post_0_2.shape[0]]
    post_norm_1_2 = post[post_0_1.shape[0] + post_0_2.shape[0] :]

    # calculate EMD and Pearson correlation stats
    EMD = [
        wasserstein_1d(dist_norm_0_1, post_norm_0_1),
        wasserstein_1d(dist_norm_0_2, post_norm_0_2),
        wasserstein_1d(dist_norm_1_2, post_norm_1_2),
    ]
    corr_stats = [
        pearsonr(x=dist_0_1, y=post_0_1)[0],
        pearsonr(x=dist_0_2, y=post_0_2)[0],
        pearsonr(x=dist_1_2, y=post_1_2)[0],
    ]

    if ID_names is None:
        ID_names = IDs.copy()

    # generate jointplot
    g = sns.JointGrid(x=dist, y=post, space=0, height=figsize[0])
    g.plot_joint(plt.hist2d, bins=50, cmap=sns.cubehelix_palette(as_cmap=True))
    sns.kdeplot(
        dist_norm_0_1,
        shade=False,
        bw_method=0.01,
        ax=g.ax_marg_x,
        color=&#34;darkorange&#34;,
        label=ID_names[0] + &#34; - &#34; + ID_names[1],
        legend=legend,
    )
    sns.kdeplot(
        dist_norm_0_2,
        shade=False,
        bw_method=0.01,
        ax=g.ax_marg_x,
        color=&#34;darkgreen&#34;,
        label=ID_names[0] + &#34; - &#34; + ID_names[2],
        legend=legend,
    )
    sns.kdeplot(
        dist_norm_1_2,
        shade=False,
        bw_method=0.01,
        ax=g.ax_marg_x,
        color=&#34;darkred&#34;,
        label=ID_names[1] + &#34; - &#34; + ID_names[2],
        legend=legend,
    )
    if legend:
        g.ax_marg_x.legend(loc=(1.01, 0.1))

    sns.kdeplot(
        y=post_norm_0_1,
        shade=False,
        bw_method=0.01,
        color=&#34;darkorange&#34;,
        ax=g.ax_marg_y,
    )
    sns.kdeplot(
        y=post_norm_0_2,
        shade=False,
        bw_method=0.01,
        color=&#34;darkgreen&#34;,
        ax=g.ax_marg_y,
    )
    sns.kdeplot(
        y=post_norm_1_2,
        shade=False,
        bw_method=0.01,
        color=&#34;darkred&#34;,
        ax=g.ax_marg_y,
    )
    g.ax_joint.plot(
        np.linspace(max(dist.min(), post.min()), 1, 100),
        np.linspace(max(dist.min(), post.min()), 1, 100),
        linestyle=&#34;dashed&#34;,
        color=sns.cubehelix_palette()[-1],
    )  # plot identity line as reference for regression
    if ax_labels:
        plt.xlabel(ax_labels[0], fontsize=&#34;xx-large&#34;, color=sns.cubehelix_palette()[-1])
        plt.ylabel(ax_labels[1], fontsize=&#34;xx-large&#34;, color=sns.cubehelix_palette()[2])

    plt.tick_params(labelleft=False, labelbottom=False)

    return corr_stats, EMD</code></pre>
</details>
</dd>
<dt id="fcc_utils.distance_stats"><code class="name flex">
<span>def <span class="ident">distance_stats</span></span>(<span>pre, post, downsample=False, verbose=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Tests for correlation between Euclidean cell-cell distances before and after
transformation by a function or DR algorithm.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>pre</code></strong> :&ensp;<code>np.array</code></dt>
<dd>vector of unique distances (pdist()) or distance matrix of shape (n_cells,
m_cells), i.e. (cdist()) before transformation/projection</dd>
<dt><strong><code>post</code></strong> :&ensp;<code>np.array</code></dt>
<dd>vector of unique distances (pdist()) or distance matrix of shape (n_cells,
m_cells), i.e. (cdist()) after transformation/projection</dd>
<dt><strong><code>downsample</code></strong> :&ensp;<code>int</code>, optional <code>(default=False)</code></dt>
<dd>number of distances to downsample to. maximum of 50M (~10k cells, if
symmetrical) is recommended for performance.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, optional <code>(default=True)</code></dt>
<dd>print progress statements to console</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>pre</code></strong> :&ensp;<code>np.array</code></dt>
<dd>vector of normalized unique distances (pdist()) or distance matrix of shape
(n_cells, m_cells), before transformation/projection</dd>
<dt><strong><code>post</code></strong> :&ensp;<code>np.array</code></dt>
<dd>vector of normalized unique distances (pdist()) or distance matrix of shape
(n_cells, m_cells), after transformation/projection</dd>
<dt><strong><code>corr_stats</code></strong> :&ensp;<code>list</code></dt>
<dd>output of <code>pearsonr()</code> function correlating the two normalized unique distance
vectors</dd>
<dt><strong><code>EMD</code></strong> :&ensp;<code>float</code></dt>
<dd>output of <code>wasserstein_1d()</code> function calculating the Earth Mover's Distance
between the two normalized unique distance vectors</dd>
<dt><code>1) performs Pearson correlation</code> of <code>distance distributions</code></dt>
<dd>&nbsp;</dd>
<dt><code>2) normalizes unique distances using min-max standardization for each dataset</code></dt>
<dd>&nbsp;</dd>
<dt><code>3) calculates Wasserstein</code> or <code>Earth-Mover's Distance for normalized distance</code></dt>
<dd>&nbsp;</dd>
<dt><code>distributions between datasets</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def distance_stats(pre, post, downsample=False, verbose=True):
    &#34;&#34;&#34;
    Tests for correlation between Euclidean cell-cell distances before and after 
    transformation by a function or DR algorithm.

    Parameters
    ----------

    pre : np.array
        vector of unique distances (pdist()) or distance matrix of shape (n_cells, 
        m_cells), i.e. (cdist()) before transformation/projection
    post : np.array
        vector of unique distances (pdist()) or distance matrix of shape (n_cells, 
        m_cells), i.e. (cdist()) after transformation/projection
    downsample : int, optional (default=False)
        number of distances to downsample to. maximum of 50M (~10k cells, if 
        symmetrical) is recommended for performance.
    verbose : bool, optional (default=True)
        print progress statements to console

    Returns
    -------

    pre : np.array
        vector of normalized unique distances (pdist()) or distance matrix of shape 
        (n_cells, m_cells), before transformation/projection
    post : np.array
        vector of normalized unique distances (pdist()) or distance matrix of shape 
        (n_cells, m_cells), after transformation/projection
    corr_stats : list
        output of `pearsonr()` function correlating the two normalized unique distance 
        vectors
    EMD : float
        output of `wasserstein_1d()` function calculating the Earth Mover&#39;s Distance 
        between the two normalized unique distance vectors

    1) performs Pearson correlation of distance distributions
    2) normalizes unique distances using min-max standardization for each dataset
    3) calculates Wasserstein or Earth-Mover&#39;s Distance for normalized distance 
    distributions between datasets
    &#34;&#34;&#34;
    # make sure the number of cells in each matrix is the same
    assert (
        pre.shape == post.shape
    ), &#39;Matrices contain different number of distances.\n{} in &#34;pre&#34;\n{} in &#34;post&#34;\n&#39;.format(
        pre.shape[0], post.shape[0]
    )

    # if distance matrix (mA x mB, result of cdist), flatten to unique cell-cell distances
    if pre.ndim == 2:
        if verbose:
            print(&#34;Flattening pre-transformation distance matrix into 1D array...&#34;)
        # if symmetric, only keep unique values (above diagonal)
        if np.allclose(pre, pre.T, rtol=1e-05, atol=1e-08):
            pre = pre[np.triu_indices(n=pre.shape[0], k=1)]
        # otherwise, flatten all distances
        else:
            pre = pre.flatten()

    # if distance matrix (mA x mB, result of cdist), flatten to unique cell-cell distances
    if post.ndim == 2:
        if verbose:
            print(&#34;Flattening post-transformation distance matrix into 1D array...&#34;)
        # if symmetric, only keep unique values (above diagonal)
        if np.allclose(post, post.T, rtol=1e-05, atol=1e-08):
            post = post[np.triu_indices(n=post.shape[0], k=1)]
        # otherwise, flatten all distances
        else:
            post = post.flatten()

    # if dataset is large, randomly downsample to reasonable number of distances for calculation
    if downsample:
        assert downsample &lt; len(
            pre
        ), &#34;Must provide downsample value smaller than total number of cell-cell distances provided in pre and post&#34;
        if verbose:
            print(&#34;Downsampling to {} total cell-cell distances...&#34;.format(downsample))
        idx = np.random.choice(np.arange(len(pre)), downsample, replace=False)
        pre = pre[idx]
        post = post[idx]

    # calculate correlation coefficient using Pearson correlation
    if verbose:
        print(&#34;Correlating distances&#34;)
    corr_stats = pearsonr(x=pre, y=post)

    # min-max normalization for fair comparison of probability distributions
    if verbose:
        print(&#34;Normalizing unique distances&#34;)
    pre -= pre.min()
    pre /= pre.ptp()

    post -= post.min()
    post /= post.ptp()

    # calculate EMD for the distance matrices
    # by default, downsample to 50M distances to speed processing time,
    # since this function often breaks with larger distributions
    if verbose:
        print(&#34;Calculating Earth-Mover&#39;s Distance between distributions&#34;)
    if len(pre) &gt; 50000000:
        idx = np.random.choice(np.arange(len(pre)), 50000000, replace=False)
        pre_EMD = pre[idx]
        post_EMD = post[idx]
        EMD = wasserstein_1d(pre_EMD, post_EMD)
    else:
        EMD = wasserstein_1d(pre, post)

    return pre, post, corr_stats, EMD</code></pre>
</details>
</dd>
<dt id="fcc_utils.find_centroids"><code class="name flex">
<span>def <span class="ident">find_centroids</span></span>(<span>adata, use_rep, obs_col='leiden')</span>
</code></dt>
<dd>
<div class="desc"><p>Finds cluster centroids</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>adata</code></strong> :&ensp;<code>anndata.AnnData</code></dt>
<dd>AnnData object</dd>
<dt><strong><code>use_rep</code></strong> :&ensp;<code>str</code></dt>
<dd>"X" or <code>adata.obsm</code> key containing space to calculate centroids in
(i.e. "X_pca")</dd>
</dl>
<p>obs_col "str, optional (default="leiden")
<code>adata.obs</code> column name containing cluster IDs</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>adata</code> is edited in place, adding <code>adata.uns["{}_centroids"]</code>,</dt>
<dt><code>adata.uns["{}_centroid_distances"]</code>, and <code>adata.uns["{}_centroid_MST"]</code></dt>
<dt><code>containing centroid coordinates, distance matrix between all centoids, and a </code></dt>
<dd>&nbsp;</dd>
<dt><code>minimum spanning tree graph between the centroids, respectively</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_centroids(adata, use_rep, obs_col=&#34;leiden&#34;):
    &#34;&#34;&#34;
    Finds cluster centroids

    Parameters
    ----------

    adata : anndata.AnnData
        AnnData object
    use_rep : str
        &#34;X&#34; or `adata.obsm` key containing space to calculate centroids in 
        (i.e. &#34;X_pca&#34;)
    obs_col &#34;str, optional (default=&#34;leiden&#34;)
        `adata.obs` column name containing cluster IDs

    Returns
    -------

    `adata` is edited in place, adding `adata.uns[&#34;{}_centroids&#34;]`, 
    `adata.uns[&#34;{}_centroid_distances&#34;]`, and `adata.uns[&#34;{}_centroid_MST&#34;]` 
    containing centroid coordinates, distance matrix between all centoids, and a 
    minimum spanning tree graph between the centroids, respectively
    &#34;&#34;&#34;
    # calculate centroids
    clu_names = adata.obs[obs_col].unique().astype(str)
    if use_rep == &#34;X&#34;:
        adata.uns[&#34;{}_centroids&#34;.format(use_rep)] = np.array(
            [
                np.mean(adata.X[adata.obs[obs_col].astype(str) == clu, :], axis=0)
                for clu in clu_names
            ]
        )
    else:
        adata.uns[&#34;{}_centroids&#34;.format(use_rep)] = np.array(
            [
                np.mean(
                    adata.obsm[use_rep][adata.obs[obs_col].astype(str) == clu, :],
                    axis=0,
                )
                for clu in clu_names
            ]
        )
    # calculate distances between all centroids
    adata.uns[&#34;{}_centroid_distances&#34;.format(use_rep)] = cdist(
        adata.uns[&#34;{}_centroids&#34;.format(use_rep)],
        adata.uns[&#34;{}_centroids&#34;.format(use_rep)],
    )
    # build networkx minimum spanning tree between centroids
    G = nx.from_numpy_matrix(adata.uns[&#34;{}_centroid_distances&#34;.format(use_rep)])
    G = nx.relabel_nodes(G, mapping=dict(zip(list(G.nodes), clu_names)), copy=True)
    adata.uns[&#34;{}_centroid_MST&#34;.format(use_rep)] = nx.minimum_spanning_tree(G)</code></pre>
</details>
</dd>
<dt id="fcc_utils.knn_graph"><code class="name flex">
<span>def <span class="ident">knn_graph</span></span>(<span>dist_matrix, k, adata, save_rep='knn')</span>
</code></dt>
<dd>
<div class="desc"><p>Builds simple binary k-nearest neighbor graph and add to anndata object</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dist_matrix</code></strong> :&ensp;<code>np.array</code></dt>
<dd>distance matrix to calculate knn graph for (i.e. <code>pdist(adata.obsm["X_pca"])</code>)</dd>
<dt><strong><code>k</code></strong> :&ensp;<code>int</code></dt>
<dd>number of nearest neighbors to determine</dd>
<dt><strong><code>adata</code></strong> :&ensp;<code>anndata.AnnData</code></dt>
<dd>AnnData object to add resulting graph to (in <code>.uns</code> slot)</dd>
<dt><strong><code>save_rep</code></strong> :&ensp;<code>str</code>, optional <code>(default="knn")</code></dt>
<dd>name of <code>.uns</code> key to save knn graph to within adata</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>adata</code> is edited in place, adding knn graph to <code>adata.uns[save_rep]</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def knn_graph(dist_matrix, k, adata, save_rep=&#34;knn&#34;):
    &#34;&#34;&#34;
    Builds simple binary k-nearest neighbor graph and add to anndata object

    Parameters
    ----------

    dist_matrix : np.array
        distance matrix to calculate knn graph for (i.e. `pdist(adata.obsm[&#34;X_pca&#34;])`)
    k : int
        number of nearest neighbors to determine
    adata : anndata.AnnData
        AnnData object to add resulting graph to (in `.uns` slot)
    save_rep : str, optional (default=&#34;knn&#34;)
        name of `.uns` key to save knn graph to within adata

    Returns
    -------

    `adata` is edited in place, adding knn graph to `adata.uns[save_rep]`
    &#34;&#34;&#34;
    adata.uns[save_rep] = {
        &#34;graph&#34;: kneighbors_graph(
            dist_matrix, k, mode=&#34;connectivity&#34;, include_self=False, n_jobs=-1
        ).toarray(),
        &#34;k&#34;: k,
    }</code></pre>
</details>
</dd>
<dt id="fcc_utils.knn_preservation"><code class="name flex">
<span>def <span class="ident">knn_preservation</span></span>(<span>pre, post)</span>
</code></dt>
<dd>
<div class="desc"><p>Tests for k-nearest neighbor preservation (%) before and after transformation by a
function or DR algorithm.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>pre</code></strong> :&ensp;<code>np.array</code></dt>
<dd>knn graph of shape (n_cells, n_cells) before transformation/projection</dd>
<dt><strong><code>post</code></strong> :&ensp;<code>np.array</code></dt>
<dd>knn graph of shape (n_cells, n_cells) after transformation/projection</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>knn_pres</code></strong> :&ensp;<code>float</code></dt>
<dd>knn preservation expressed as a percentage out of 100 %</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def knn_preservation(pre, post):
    &#34;&#34;&#34;
    Tests for k-nearest neighbor preservation (%) before and after transformation by a 
    function or DR algorithm.

    Parameters
    ----------

    pre : np.array
        knn graph of shape (n_cells, n_cells) before transformation/projection
    post : np.array
        knn graph of shape (n_cells, n_cells) after transformation/projection

    Returns
    -------

    knn_pres : float
        knn preservation expressed as a percentage out of 100 %
    &#34;&#34;&#34;
    # make sure the number of cells in each matrix is the same
    assert (
        pre.shape == post.shape
    ), &#39;Matrices contain different number of cells.\n{} in &#34;pre&#34;\n{} in &#34;post&#34;\n&#39;.format(
        pre.shape[0], post.shape[0]
    )
    return np.round(
        (np.isclose(pre, post, rtol=1e-05, atol=1e-08).sum() / (pre.shape[0] ** 2))
        * 100,
        4,
    )</code></pre>
</details>
</dd>
<dt id="fcc_utils.structure_preservation_sc"><code class="name flex">
<span>def <span class="ident">structure_preservation_sc</span></span>(<span>adata, latent, native='X', metric='euclidean', k=30, downsample=False, verbose=True, force_recalc=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Wrapper function for full structural preservation workflow applied to <code>scanpy</code>
AnnData object</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>adata</code></strong> :&ensp;<code>anndata.AnnData</code></dt>
<dd>AnnData object with latent space to test in <code>.obsm</code> slot, and native
(reference) space in <code>.X</code> or <code>.obsm</code></dd>
<dt><strong><code>latent</code></strong> :&ensp;<code>str</code></dt>
<dd><code>adata.obsm</code> key that contains low-dimensional latent space for testing</dd>
<dt><strong><code>native</code></strong> :&ensp;<code>str</code>, optional <code>(default="X")</code></dt>
<dd><code>adata.obsm</code> key or <code>.X</code> containing high-dimensional native space, which
should be direct input to dimension reduction that generated latent <code>.obsm</code>
for fair comparison. default "X", which uses <code>adata.X</code>.</dd>
<dt><strong><code>metric</code></strong> :&ensp;<code>str {"chebyshev","cityblock","euclidean","minkowski","mahalanobis",</code></dt>
<dd>&nbsp;</dd>
<dt>"seuclidean"}, optional (default="euclidean")</dt>
<dt>distance metric to use</dt>
<dt><strong><code>k</code></strong> :&ensp;<code>int</code>, optional <code>(default=30)</code></dt>
<dd>number of nearest neighbors to test preservation</dd>
<dt><strong><code>downsample</code></strong> :&ensp;<code>int</code>, optional <code>(default=False)</code></dt>
<dd>number of distances to downsample to. maximum of 50M (~10k cells, if
symmetrical) is recommended for performance.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, optional <code>(default=True)</code></dt>
<dd>print progress statements to console</dd>
<dt><strong><code>force_recalc</code></strong> :&ensp;<code>bool</code>, optional <code>(default=False)</code></dt>
<dd>if True, recalculate all distances and neighbor graphs, regardless of their
presence in <code>adata</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>corr_stats</code></strong> :&ensp;<code>list</code></dt>
<dd>output of <code>pearsonr()</code> function correlating the two normalized unique distance
vectors</dd>
<dt><strong><code>EMD</code></strong> :&ensp;<code>float</code></dt>
<dd>output of <code>wasserstein_1d()</code> function calculating the Earth Mover's Distance
between the two normalized unique distance vectors</dd>
<dt><strong><code>knn_pres</code></strong> :&ensp;<code>float</code></dt>
<dd>knn preservation expressed as a percentage out of 100 %</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def structure_preservation_sc(
    adata,
    latent,
    native=&#34;X&#34;,
    metric=&#34;euclidean&#34;,
    k=30,
    downsample=False,
    verbose=True,
    force_recalc=False,
):
    &#34;&#34;&#34;
    Wrapper function for full structural preservation workflow applied to `scanpy` 
    AnnData object

    Parameters
    ----------

    adata : anndata.AnnData
        AnnData object with latent space to test in `.obsm` slot, and native 
        (reference) space in `.X` or `.obsm`
    latent : str
        `adata.obsm` key that contains low-dimensional latent space for testing
    native : str, optional (default=&#34;X&#34;)
        `adata.obsm` key or `.X` containing high-dimensional native space, which 
        should be direct input to dimension reduction that generated latent `.obsm` 
        for fair comparison. default &#34;X&#34;, which uses `adata.X`.
    metric : str {&#34;chebyshev&#34;,&#34;cityblock&#34;,&#34;euclidean&#34;,&#34;minkowski&#34;,&#34;mahalanobis&#34;,
    &#34;seuclidean&#34;}, optional (default=&#34;euclidean&#34;)
        distance metric to use
    k : int, optional (default=30)
        number of nearest neighbors to test preservation
    downsample : int, optional (default=False)
        number of distances to downsample to. maximum of 50M (~10k cells, if 
        symmetrical) is recommended for performance.
    verbose : bool, optional (default=True)
        print progress statements to console
    force_recalc : bool, optional (default=False)
        if True, recalculate all distances and neighbor graphs, regardless of their 
        presence in `adata`

    Returns
    -------

    corr_stats : list
        output of `pearsonr()` function correlating the two normalized unique distance 
        vectors
    EMD : float
        output of `wasserstein_1d()` function calculating the Earth Mover&#39;s Distance 
        between the two normalized unique distance vectors
    knn_pres : float
        knn preservation expressed as a percentage out of 100 %
    &#34;&#34;&#34;
    # 0) determine native space according to argument
    if native == &#34;X&#34;:
        native_space = adata.X.copy()
    else:
        native_space = adata.obsm[native].copy()

    # 1) calculate unique cell-cell distances
    if (
        &#34;{}_distances&#34;.format(native) not in adata.uns.keys() or force_recalc
    ):  # check for existence in AnnData to prevent re-work
        if verbose:
            print(&#34;Calculating unique distances for native space, {}&#34;.format(native))
        adata.uns[&#34;{}_distances&#34;.format(native)] = cdist(
            native_space, native_space, metric=metric
        )

    if (
        &#34;{}_distances&#34;.format(latent) not in adata.uns.keys() or force_recalc
    ):  # check for existence in AnnData to prevent re-work
        if verbose:
            print(&#34;Calculating unique distances for latent space, {}&#34;.format(latent))
        adata.uns[&#34;{}_distances&#34;.format(latent)] = cdist(
            adata.obsm[latent], adata.obsm[latent], metric=metric
        )

    # 2) get correlation and EMD values, and return normalized distance vectors for plotting distributions
    (
        adata.uns[&#34;{}_norm_distances&#34;.format(native)],
        adata.uns[&#34;{}_norm_distances&#34;.format(latent)],
        corr_stats,
        EMD,
    ) = distance_stats(
        pre=adata.uns[&#34;{}_distances&#34;.format(native)].copy(),
        post=adata.uns[&#34;{}_distances&#34;.format(latent)].copy(),
        verbose=verbose,
        downsample=downsample,
    )

    # 3) determine neighbors
    if (
        &#34;{}_neighbors&#34;.format(native) not in adata.uns.keys() or force_recalc
    ):  # check for existence in AnnData to prevent re-work
        if verbose:
            print(
                &#34;{}-nearest neighbor calculation for native space, {}&#34;.format(k, native)
            )
        knn_graph(
            adata.uns[&#34;{}_distances&#34;.format(native)],
            k=k,
            adata=adata,
            save_rep=&#34;{}_knn&#34;.format(native),
        )

    if (
        &#34;{}_neighbors&#34;.format(latent) not in adata.uns.keys() or force_recalc
    ):  # check for existence in AnnData to prevent re-work
        if verbose:
            print(
                &#34;{}-nearest neighbor calculation for latent space, {}&#34;.format(k, latent)
            )
        knn_graph(
            adata.uns[&#34;{}_distances&#34;.format(latent)],
            k=k,
            adata=adata,
            save_rep=&#34;{}_knn&#34;.format(latent),
        )

    # 4) calculate neighbor preservation
    if verbose:
        print(&#34;Determining nearest neighbor preservation&#34;)
    if (
        adata.uns[&#34;{}_knn&#34;.format(native)][&#34;k&#34;]
        != adata.uns[&#34;{}_knn&#34;.format(latent)][&#34;k&#34;]
    ):
        warnings.warn(
            &#39;Warning: Nearest-neighbor graphs constructed with different k values. k={} in &#34;{}_neighbors&#34;, while k={} in &#34;{}_neighbors&#34;. Consider re-generating neighbors graphs by setting force_recalc=True.&#39;.format(
                adata.uns[&#34;{}_knn&#34;.format(native)][&#34;k&#34;],
                native,
                adata.uns[&#34;{}_knn&#34;.format(latent)][&#34;k&#34;],
                latent,
            )
        )
    knn_pres = knn_preservation(
        pre=adata.uns[&#34;{}_knn&#34;.format(native)][&#34;graph&#34;],
        post=adata.uns[&#34;{}_knn&#34;.format(latent)][&#34;graph&#34;],
    )

    if verbose:
        print(&#34;Done!&#34;)
    return corr_stats, EMD, knn_pres</code></pre>
</details>
</dd>
<dt id="fcc_utils.subset_uns_by_ID"><code class="name flex">
<span>def <span class="ident">subset_uns_by_ID</span></span>(<span>adata, uns_keys, obs_col, IDs)</span>
</code></dt>
<dd>
<div class="desc"><p>Subsets symmetrical distance matrices and knn graphs in <code>adata.uns</code> by one or more
IDs defined in <code>adata.obs</code></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>adata</code></strong> :&ensp;<code>anndata.AnnData</code></dt>
<dd>AnnData object</dd>
<dt><strong><code>uns_keys</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>list of keys in <code>adata.uns</code> to subset. new <code>adata.uns</code> keys will be saved with
ID appended to name (i.e. <code>adata.uns["knn"]</code> -&gt; <code>adata.uns["knn_ID1"]</code>)</dd>
<dt><strong><code>obs_col</code></strong> :&ensp;<code>str</code></dt>
<dd>name of column in <code>adata.obs</code> to use as cell IDs (i.e. "leiden")</dd>
<dt><strong><code>IDs</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>list of IDs to include in subset</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>adata</code> is edited in place, adding new <code>.uns</code> keys for each ID</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def subset_uns_by_ID(adata, uns_keys, obs_col, IDs):
    &#34;&#34;&#34;
    Subsets symmetrical distance matrices and knn graphs in `adata.uns` by one or more 
    IDs defined in `adata.obs`

    Parameters
    ----------

    adata : anndata.AnnData
        AnnData object
    uns_keys : list of str
        list of keys in `adata.uns` to subset. new `adata.uns` keys will be saved with 
        ID appended to name (i.e. `adata.uns[&#34;knn&#34;]` -&gt; `adata.uns[&#34;knn_ID1&#34;]`)
    obs_col : str
        name of column in `adata.obs` to use as cell IDs (i.e. &#34;leiden&#34;)
    IDs : list of str
        list of IDs to include in subset

    Returns
    -------

    `adata` is edited in place, adding new `.uns` keys for each ID
    &#34;&#34;&#34;
    for key in uns_keys:
        tmp = adata.uns[key][
            adata.obs[obs_col].isin(IDs), :
        ]  # subset symmetrical uns matrix along axis 0
        tmp = tmp[
            :, adata.obs[obs_col].isin(IDs)
        ]  # subset symmetrical uns matrix along axis 1

        adata.uns[
            &#34;{}_{}&#34;.format(key, &#34;_&#34;.join([str(x) for x in IDs]))
        ] = tmp  # save new .uns key by appending IDs to original key name</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="fcc_utils.DR_plot"><code class="flex name class">
<span>class <span class="ident">DR_plot</span></span>
<span>(</span><span>dim_name='dim', figsize=(5, 5), ax_labels=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Class defining pretty plots of dimension-reduced embeddings such as PCA, t-SNE,
and UMAP</p>
<h2 id="attributes">Attributes</h2>
<p>.fig : matplotlib.figure
the figure object on which data will be plotted
.ax : matplotlib.axes.ax
the axes within <code>self.fig</code>
.cmap : matplotlib.pyplot.cmap
color map to use for plotting; default="plasma"</p>
<h2 id="methods">Methods</h2>
<p>.plot()
utility plotting function that can be passed any numpy array in the <code>data</code>
parameter
.plot_IDs()
plots one or more cluster IDs on top of an <code>.obsm</code> from an AnnData object
.plot_centroids()
plots cluster centroids defined using <code><a title="fcc_utils.find_centroids" href="#fcc_utils.find_centroids">find_centroids()</a></code> function on AnnData
object</p>
<p>Initializes <code><a title="fcc_utils.DR_plot" href="#fcc_utils.DR_plot">DR_plot</a></code> class</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dim_name</code></strong> :&ensp;<code>str</code>, optional <code>(default="dim")</code></dt>
<dd>how to label axes ("dim 1" on x and "dim 2" on y by default)</dd>
<dt><strong><code>figsize</code></strong> :&ensp;<code>tuple</code> of <code>float</code>, optional <code>(default=(5,5))</code></dt>
<dd>size of resulting figure in inches</dd>
<dt><strong><code>ax_labels</code></strong> :&ensp;<code>bool</code>, optional <code>(default=True)</code></dt>
<dd>draw arrows and dimension names in lower left corner of plot</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Initializes <code>self.fig</code> and <code>self.ax</code> according to input specs</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DR_plot:
    &#34;&#34;&#34;
    Class defining pretty plots of dimension-reduced embeddings such as PCA, t-SNE, 
    and UMAP

    Attributes
    ----------

    .fig : matplotlib.figure
        the figure object on which data will be plotted
    .ax : matplotlib.axes.ax
        the axes within `self.fig`
    .cmap : matplotlib.pyplot.cmap
        color map to use for plotting; default=&#34;plasma&#34;

    Methods
    -------

    .plot()
        utility plotting function that can be passed any numpy array in the `data` 
        parameter
    .plot_IDs()
        plots one or more cluster IDs on top of an `.obsm` from an AnnData object
    .plot_centroids()
        plots cluster centroids defined using `find_centroids()` function on AnnData 
        object
    &#34;&#34;&#34;

    def __init__(self, dim_name=&#34;dim&#34;, figsize=(5, 5), ax_labels=True):
        &#34;&#34;&#34;
        Initializes `DR_plot` class

        Parameters
        ----------

        dim_name : str, optional (default=&#34;dim&#34;)
            how to label axes (&#34;dim 1&#34; on x and &#34;dim 2&#34; on y by default)
        figsize : tuple of float, optional (default=(5,5))
            size of resulting figure in inches
        ax_labels : bool, optional (default=True)
            draw arrows and dimension names in lower left corner of plot

        Returns
        -------

        Initializes `self.fig` and `self.ax` according to input specs
        &#34;&#34;&#34;
        self.fig, self.ax = plt.subplots(1, figsize=figsize)
        self.cmap = plt.get_cmap(&#34;plasma&#34;)

        if ax_labels:
            plt.xlabel(&#34;{} 1&#34;.format(dim_name), fontsize=14)
            self.ax.xaxis.set_label_coords(0.2, -0.025)
            plt.ylabel(&#34;{} 2&#34;.format(dim_name), fontsize=14)
            self.ax.yaxis.set_label_coords(-0.025, 0.2)

            plt.annotate(
                &#34;&#34;,
                textcoords=&#34;axes fraction&#34;,
                xycoords=&#34;axes fraction&#34;,
                xy=(-0.006, 0),
                xytext=(0.2, 0),
                arrowprops=dict(arrowstyle=&#34;&lt;-&#34;, lw=2, color=&#34;black&#34;),
            )
            plt.annotate(
                &#34;&#34;,
                textcoords=&#34;axes fraction&#34;,
                xycoords=&#34;axes fraction&#34;,
                xy=(0, -0.006),
                xytext=(0, 0.2),
                arrowprops=dict(arrowstyle=&#34;&lt;-&#34;, lw=2, color=&#34;black&#34;),
            )

        plt.tick_params(labelbottom=False, labelleft=False)
        sns.despine(left=True, bottom=True)
        plt.tight_layout()

    def plot(self, data, color, pt_size=75, legend=None, save_to=None):
        &#34;&#34;&#34;
        General plotting function for dimensionality reduction outputs with cute 
        arrows and labels

        Parameters
        ----------

        data : np.array
            array containing variables in columns and observations in rows
        color : list
            list of length `nrow(data)` to determine how points should be colored (ie. 
            `adata.obs[&#34;leiden&#34;].values` to color by &#34;leiden&#34; cluster categories)
        pt_size : float, optional (default=75)
            size of points in plot
        legend : str {&#34;full&#34;,&#34;brief&#34;}, optional (default=None)
            string describing the legend size. None for no legend
        save_to : str, optional (default=None)
            path to `.png` file to save output. do not save if None

        Returns
        -------

        `self.fig`, `self.ax` edited; plot saved to `.png` file if `save_to` is not 
        None
        &#34;&#34;&#34;
        sns.scatterplot(
            x=data[:, 0],
            y=data[:, 1],
            s=pt_size,
            alpha=0.7,
            hue=color,
            legend=legend,
            edgecolor=&#34;none&#34;,
            ax=self.ax,
        )

        if legend is not None:
            plt.legend(
                bbox_to_anchor=(1, 1, 0.2, 0.2),
                loc=&#34;lower left&#34;,
                frameon=False,
                fontsize=&#34;small&#34;,
            )

        if save_to is None:
            return
        else:
            plt.savefig(fname=save_to, transparent=True, bbox_inches=&#34;tight&#34;, dpi=1000)

    def plot_IDs(
        self, adata, use_rep, obs_col=&#34;leiden&#34;, IDs=&#34;all&#34;, pt_size=75, save_to=None
    ):
        &#34;&#34;&#34;
        General plotting function for dimensionality reduction outputs with 
        categorical colors (i.e. &#34;leiden&#34; or &#34;louvain&#34;) and cute arrows and labels

        Parameters
        ----------

        adata : anndata.AnnData
            object to pull dimensionality reduction from
        use_rep : str
            `adata.obsm` key to plot from (i.e. &#34;X_pca&#34;)
        obs_col : str, optional (default=&#34;leiden&#34;)
            name of column in `adata.obs` to use as cell IDs (i.e. &#34;leiden&#34;)
        IDs : list of str, optional (default=&#34;all&#34;)
            list of IDs to plot, graying out cells not assigned to those IDs. if 
            &#34;all&#34;, show all ID categories.
        pt_size : float, optional (default=75)
            size of points in plot
        save_to : str, optional (default=None)
            path to `.png` file to save output. do not save if None

        Returns
        -------

        `self.fig`, `self.ax` edited; plot saved to `.png` file if `save_to` is not 
        None
        &#34;&#34;&#34;
        plotter = adata.obsm[use_rep]
        clu_names = adata.obs[obs_col].unique().astype(str)

        # use existing scanpy colors, if applicable
        if obs_col == &#34;leiden&#34; and &#34;leiden_colors&#34; in adata.uns.keys():
            colors = [
                adata.uns[&#34;leiden_colors&#34;][x]
                for x in adata.obs.leiden.unique().astype(int)
            ]
        elif obs_col == &#34;louvain&#34; and &#34;louvain_colors&#34; in adata.uns.keys():
            colors = [
                adata.uns[&#34;louvain_colors&#34;][x]
                for x in adata.obs.louvain.unique().astype(int)
            ]
        # otherwise, get new color mapping from obs_col using self.cmap
        else:
            colors = self.cmap(np.linspace(0, 1, len(clu_names)))

        cdict = dict(zip(clu_names, colors))

        if IDs == &#34;all&#34;:
            self.ax.scatter(
                x=plotter[:, 0],
                y=plotter[:, 1],
                s=pt_size,
                alpha=0.7,
                c=[cdict[x] for x in adata.obs[obs_col].astype(str)],
                edgecolor=&#34;none&#34;,
            )

        else:
            sns.scatterplot(
                x=plotter[-adata.obs[obs_col].isin(IDs), 0],
                y=plotter[-adata.obs[obs_col].isin(IDs), 1],
                ax=self.ax,
                s=pt_size,
                alpha=0.1,
                color=&#34;gray&#34;,
                legend=False,
                edgecolor=&#34;none&#34;,
            )
            plt.scatter(
                x=plotter[adata.obs[obs_col].isin(IDs), 0],
                y=plotter[adata.obs[obs_col].isin(IDs), 1],
                s=pt_size,
                alpha=0.7,
                c=[
                    cdict[x]
                    for x in adata.obs.loc[
                        adata.obs[obs_col].isin(IDs), obs_col
                    ].astype(str)
                ],
                edgecolor=&#34;none&#34;,
            )

        if save_to is None:
            return
        else:
            plt.savefig(fname=save_to, transparent=True, bbox_inches=&#34;tight&#34;, dpi=1000)

    def plot_centroids(
        self,
        adata,
        use_rep,
        obs_col=&#34;leiden&#34;,
        ctr_size=300,
        pt_size=75,
        draw_edges=True,
        highlight_edges=False,
        save_to=None,
    ):
        &#34;&#34;&#34;
        General plotting function for cluster centroid graph and MST 
        (i.e. from &#34;leiden&#34; or &#34;louvain&#34;) and cute arrows and labels

        Parameters
        ----------

        adata : anndata.AnnData
            object to pull dimensionality reduction from
        use_rep : str
            `adata.obsm` key to plot from (i.e. &#34;X_pca&#34;)
        obs_col : str, optional (default=&#34;leiden&#34;)
            name of column in `adata.obs` to use as cell IDs (i.e. &#34;leiden&#34;)
        ctr_size : float, optional (default=300)
            size of centroid points in plot
        pt_size : float, optional (default=75)
            size of points in plot
        draw_edges : bool, optional (default=True)
            draw edges of minimum spanning tree between all centroids
        highlight_edges : list of int, optional (default=False)
            list of edge IDs as tuples to highlight in red on plot. e.g. 
            `set(adata.uns[&#39;X_tsne_centroid_MST&#39;].edges).difference(set(adata.uns[&#39;X_umap_centroid_MST&#39;].edges))`
            with output {(0,3), (0,7)} says that edges from centroid 0 to 3 and 0 to 7 
            are found in &#39;X_tsne_centroids&#39; but not in &#39;X_umap_centroids&#39;. highlight 
            the edges to show this.
        save_to : str, optional (default=None)
            path to `.png` file to save output. do not save if None

        Returns
        -------

        `self.fig`, `self.ax` edited; plot saved to `.png` file if `save_to` is not 
        None
        &#34;&#34;&#34;
        clu_names = adata.obs[obs_col].unique().astype(str)
        # use existing scanpy colors, if applicable
        if obs_col == &#34;leiden&#34; and &#34;leiden_colors&#34; in adata.uns.keys():
            colors = [
                adata.uns[&#34;leiden_colors&#34;][x]
                for x in adata.obs.leiden.unique().astype(int)
            ]
        elif obs_col == &#34;louvain&#34; and &#34;louvain_colors&#34; in adata.uns.keys():
            colors = [
                adata.uns[&#34;louvain_colors&#34;][x]
                for x in adata.obs.louvain.unique().astype(int)
            ]
        # otherwise, get new color mapping from obs_col using self.cmap
        else:
            colors = self.cmap(np.linspace(0, 1, len(clu_names)))

        # draw points in embedding first
        sns.scatterplot(
            x=adata.obsm[use_rep][:, 0],
            y=adata.obsm[use_rep][:, 1],
            ax=self.ax,
            s=pt_size,
            alpha=0.1,
            color=&#34;gray&#34;,
            legend=False,
            edgecolor=&#34;none&#34;,
        )

        # draw MST edges if desired, otherwise just draw centroids
        if not draw_edges:
            self.ax.scatter(
                x=adata.uns[&#34;{}_centroids&#34;.format(use_rep)][:, 0],
                y=adata.uns[&#34;{}_centroids&#34;.format(use_rep)][:, 1],
                s=ctr_size,
                c=colors,
                edgecolor=&#34;none&#34;,
            )
        else:
            pos = dict(zip(clu_names, adata.uns[&#34;{}_centroids&#34;.format(use_rep)][:, :2]))
            nx.draw_networkx(
                adata.uns[&#34;{}_centroid_MST&#34;.format(use_rep)],
                pos=pos,
                ax=self.ax,
                with_labels=False,
                width=2,
                node_size=ctr_size,
                node_color=colors,
            )
            # highlight edges if desired
            if highlight_edges:
                nx.draw_networkx_edges(
                    adata.uns[&#34;{}_centroid_MST&#34;.format(use_rep)],
                    pos=pos,
                    ax=self.ax,
                    edgelist=highlight_edges,
                    width=5,
                    edge_color=&#34;red&#34;,
                )

        if save_to is None:
            return
        else:
            plt.savefig(fname=save_to, transparent=True, bbox_inches=&#34;tight&#34;, dpi=1000)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="fcc_utils.DR_plot.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, data, color, pt_size=75, legend=None, save_to=None)</span>
</code></dt>
<dd>
<div class="desc"><p>General plotting function for dimensionality reduction outputs with cute
arrows and labels</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>np.array</code></dt>
<dd>array containing variables in columns and observations in rows</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>list</code></dt>
<dd>list of length <code>nrow(data)</code> to determine how points should be colored (ie.
<code>adata.obs["leiden"].values</code> to color by "leiden" cluster categories)</dd>
<dt><strong><code>pt_size</code></strong> :&ensp;<code>float</code>, optional <code>(default=75)</code></dt>
<dd>size of points in plot</dd>
<dt><strong><code>legend</code></strong> :&ensp;<code>str {"full","brief"}</code>, optional <code>(default=None)</code></dt>
<dd>string describing the legend size. None for no legend</dd>
<dt><strong><code>save_to</code></strong> :&ensp;<code>str</code>, optional <code>(default=None)</code></dt>
<dd>path to <code>.png</code> file to save output. do not save if None</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>self.fig</code>, <code>self.ax</code> edited; plot saved to <code>.png</code> file if <code>save_to</code> is not</dt>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self, data, color, pt_size=75, legend=None, save_to=None):
    &#34;&#34;&#34;
    General plotting function for dimensionality reduction outputs with cute 
    arrows and labels

    Parameters
    ----------

    data : np.array
        array containing variables in columns and observations in rows
    color : list
        list of length `nrow(data)` to determine how points should be colored (ie. 
        `adata.obs[&#34;leiden&#34;].values` to color by &#34;leiden&#34; cluster categories)
    pt_size : float, optional (default=75)
        size of points in plot
    legend : str {&#34;full&#34;,&#34;brief&#34;}, optional (default=None)
        string describing the legend size. None for no legend
    save_to : str, optional (default=None)
        path to `.png` file to save output. do not save if None

    Returns
    -------

    `self.fig`, `self.ax` edited; plot saved to `.png` file if `save_to` is not 
    None
    &#34;&#34;&#34;
    sns.scatterplot(
        x=data[:, 0],
        y=data[:, 1],
        s=pt_size,
        alpha=0.7,
        hue=color,
        legend=legend,
        edgecolor=&#34;none&#34;,
        ax=self.ax,
    )

    if legend is not None:
        plt.legend(
            bbox_to_anchor=(1, 1, 0.2, 0.2),
            loc=&#34;lower left&#34;,
            frameon=False,
            fontsize=&#34;small&#34;,
        )

    if save_to is None:
        return
    else:
        plt.savefig(fname=save_to, transparent=True, bbox_inches=&#34;tight&#34;, dpi=1000)</code></pre>
</details>
</dd>
<dt id="fcc_utils.DR_plot.plot_IDs"><code class="name flex">
<span>def <span class="ident">plot_IDs</span></span>(<span>self, adata, use_rep, obs_col='leiden', IDs='all', pt_size=75, save_to=None)</span>
</code></dt>
<dd>
<div class="desc"><p>General plotting function for dimensionality reduction outputs with
categorical colors (i.e. "leiden" or "louvain") and cute arrows and labels</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>adata</code></strong> :&ensp;<code>anndata.AnnData</code></dt>
<dd>object to pull dimensionality reduction from</dd>
<dt><strong><code>use_rep</code></strong> :&ensp;<code>str</code></dt>
<dd><code>adata.obsm</code> key to plot from (i.e. "X_pca")</dd>
<dt><strong><code>obs_col</code></strong> :&ensp;<code>str</code>, optional <code>(default="leiden")</code></dt>
<dd>name of column in <code>adata.obs</code> to use as cell IDs (i.e. "leiden")</dd>
<dt><strong><code>IDs</code></strong> :&ensp;<code>list</code> of <code>str</code>, optional <code>(default="all")</code></dt>
<dd>list of IDs to plot, graying out cells not assigned to those IDs. if
"all", show all ID categories.</dd>
<dt><strong><code>pt_size</code></strong> :&ensp;<code>float</code>, optional <code>(default=75)</code></dt>
<dd>size of points in plot</dd>
<dt><strong><code>save_to</code></strong> :&ensp;<code>str</code>, optional <code>(default=None)</code></dt>
<dd>path to <code>.png</code> file to save output. do not save if None</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>self.fig</code>, <code>self.ax</code> edited; plot saved to <code>.png</code> file if <code>save_to</code> is not</dt>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_IDs(
    self, adata, use_rep, obs_col=&#34;leiden&#34;, IDs=&#34;all&#34;, pt_size=75, save_to=None
):
    &#34;&#34;&#34;
    General plotting function for dimensionality reduction outputs with 
    categorical colors (i.e. &#34;leiden&#34; or &#34;louvain&#34;) and cute arrows and labels

    Parameters
    ----------

    adata : anndata.AnnData
        object to pull dimensionality reduction from
    use_rep : str
        `adata.obsm` key to plot from (i.e. &#34;X_pca&#34;)
    obs_col : str, optional (default=&#34;leiden&#34;)
        name of column in `adata.obs` to use as cell IDs (i.e. &#34;leiden&#34;)
    IDs : list of str, optional (default=&#34;all&#34;)
        list of IDs to plot, graying out cells not assigned to those IDs. if 
        &#34;all&#34;, show all ID categories.
    pt_size : float, optional (default=75)
        size of points in plot
    save_to : str, optional (default=None)
        path to `.png` file to save output. do not save if None

    Returns
    -------

    `self.fig`, `self.ax` edited; plot saved to `.png` file if `save_to` is not 
    None
    &#34;&#34;&#34;
    plotter = adata.obsm[use_rep]
    clu_names = adata.obs[obs_col].unique().astype(str)

    # use existing scanpy colors, if applicable
    if obs_col == &#34;leiden&#34; and &#34;leiden_colors&#34; in adata.uns.keys():
        colors = [
            adata.uns[&#34;leiden_colors&#34;][x]
            for x in adata.obs.leiden.unique().astype(int)
        ]
    elif obs_col == &#34;louvain&#34; and &#34;louvain_colors&#34; in adata.uns.keys():
        colors = [
            adata.uns[&#34;louvain_colors&#34;][x]
            for x in adata.obs.louvain.unique().astype(int)
        ]
    # otherwise, get new color mapping from obs_col using self.cmap
    else:
        colors = self.cmap(np.linspace(0, 1, len(clu_names)))

    cdict = dict(zip(clu_names, colors))

    if IDs == &#34;all&#34;:
        self.ax.scatter(
            x=plotter[:, 0],
            y=plotter[:, 1],
            s=pt_size,
            alpha=0.7,
            c=[cdict[x] for x in adata.obs[obs_col].astype(str)],
            edgecolor=&#34;none&#34;,
        )

    else:
        sns.scatterplot(
            x=plotter[-adata.obs[obs_col].isin(IDs), 0],
            y=plotter[-adata.obs[obs_col].isin(IDs), 1],
            ax=self.ax,
            s=pt_size,
            alpha=0.1,
            color=&#34;gray&#34;,
            legend=False,
            edgecolor=&#34;none&#34;,
        )
        plt.scatter(
            x=plotter[adata.obs[obs_col].isin(IDs), 0],
            y=plotter[adata.obs[obs_col].isin(IDs), 1],
            s=pt_size,
            alpha=0.7,
            c=[
                cdict[x]
                for x in adata.obs.loc[
                    adata.obs[obs_col].isin(IDs), obs_col
                ].astype(str)
            ],
            edgecolor=&#34;none&#34;,
        )

    if save_to is None:
        return
    else:
        plt.savefig(fname=save_to, transparent=True, bbox_inches=&#34;tight&#34;, dpi=1000)</code></pre>
</details>
</dd>
<dt id="fcc_utils.DR_plot.plot_centroids"><code class="name flex">
<span>def <span class="ident">plot_centroids</span></span>(<span>self, adata, use_rep, obs_col='leiden', ctr_size=300, pt_size=75, draw_edges=True, highlight_edges=False, save_to=None)</span>
</code></dt>
<dd>
<div class="desc"><p>General plotting function for cluster centroid graph and MST
(i.e. from "leiden" or "louvain") and cute arrows and labels</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>adata</code></strong> :&ensp;<code>anndata.AnnData</code></dt>
<dd>object to pull dimensionality reduction from</dd>
<dt><strong><code>use_rep</code></strong> :&ensp;<code>str</code></dt>
<dd><code>adata.obsm</code> key to plot from (i.e. "X_pca")</dd>
<dt><strong><code>obs_col</code></strong> :&ensp;<code>str</code>, optional <code>(default="leiden")</code></dt>
<dd>name of column in <code>adata.obs</code> to use as cell IDs (i.e. "leiden")</dd>
<dt><strong><code>ctr_size</code></strong> :&ensp;<code>float</code>, optional <code>(default=300)</code></dt>
<dd>size of centroid points in plot</dd>
<dt><strong><code>pt_size</code></strong> :&ensp;<code>float</code>, optional <code>(default=75)</code></dt>
<dd>size of points in plot</dd>
<dt><strong><code>draw_edges</code></strong> :&ensp;<code>bool</code>, optional <code>(default=True)</code></dt>
<dd>draw edges of minimum spanning tree between all centroids</dd>
<dt><strong><code>highlight_edges</code></strong> :&ensp;<code>list</code> of <code>int</code>, optional <code>(default=False)</code></dt>
<dd>list of edge IDs as tuples to highlight in red on plot. e.g.
<code>set(adata.uns['X_tsne_centroid_MST'].edges).difference(set(adata.uns['X_umap_centroid_MST'].edges))</code>
with output {(0,3), (0,7)} says that edges from centroid 0 to 3 and 0 to 7
are found in 'X_tsne_centroids' but not in 'X_umap_centroids'. highlight
the edges to show this.</dd>
<dt><strong><code>save_to</code></strong> :&ensp;<code>str</code>, optional <code>(default=None)</code></dt>
<dd>path to <code>.png</code> file to save output. do not save if None</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>self.fig</code>, <code>self.ax</code> edited; plot saved to <code>.png</code> file if <code>save_to</code> is not</dt>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_centroids(
    self,
    adata,
    use_rep,
    obs_col=&#34;leiden&#34;,
    ctr_size=300,
    pt_size=75,
    draw_edges=True,
    highlight_edges=False,
    save_to=None,
):
    &#34;&#34;&#34;
    General plotting function for cluster centroid graph and MST 
    (i.e. from &#34;leiden&#34; or &#34;louvain&#34;) and cute arrows and labels

    Parameters
    ----------

    adata : anndata.AnnData
        object to pull dimensionality reduction from
    use_rep : str
        `adata.obsm` key to plot from (i.e. &#34;X_pca&#34;)
    obs_col : str, optional (default=&#34;leiden&#34;)
        name of column in `adata.obs` to use as cell IDs (i.e. &#34;leiden&#34;)
    ctr_size : float, optional (default=300)
        size of centroid points in plot
    pt_size : float, optional (default=75)
        size of points in plot
    draw_edges : bool, optional (default=True)
        draw edges of minimum spanning tree between all centroids
    highlight_edges : list of int, optional (default=False)
        list of edge IDs as tuples to highlight in red on plot. e.g. 
        `set(adata.uns[&#39;X_tsne_centroid_MST&#39;].edges).difference(set(adata.uns[&#39;X_umap_centroid_MST&#39;].edges))`
        with output {(0,3), (0,7)} says that edges from centroid 0 to 3 and 0 to 7 
        are found in &#39;X_tsne_centroids&#39; but not in &#39;X_umap_centroids&#39;. highlight 
        the edges to show this.
    save_to : str, optional (default=None)
        path to `.png` file to save output. do not save if None

    Returns
    -------

    `self.fig`, `self.ax` edited; plot saved to `.png` file if `save_to` is not 
    None
    &#34;&#34;&#34;
    clu_names = adata.obs[obs_col].unique().astype(str)
    # use existing scanpy colors, if applicable
    if obs_col == &#34;leiden&#34; and &#34;leiden_colors&#34; in adata.uns.keys():
        colors = [
            adata.uns[&#34;leiden_colors&#34;][x]
            for x in adata.obs.leiden.unique().astype(int)
        ]
    elif obs_col == &#34;louvain&#34; and &#34;louvain_colors&#34; in adata.uns.keys():
        colors = [
            adata.uns[&#34;louvain_colors&#34;][x]
            for x in adata.obs.louvain.unique().astype(int)
        ]
    # otherwise, get new color mapping from obs_col using self.cmap
    else:
        colors = self.cmap(np.linspace(0, 1, len(clu_names)))

    # draw points in embedding first
    sns.scatterplot(
        x=adata.obsm[use_rep][:, 0],
        y=adata.obsm[use_rep][:, 1],
        ax=self.ax,
        s=pt_size,
        alpha=0.1,
        color=&#34;gray&#34;,
        legend=False,
        edgecolor=&#34;none&#34;,
    )

    # draw MST edges if desired, otherwise just draw centroids
    if not draw_edges:
        self.ax.scatter(
            x=adata.uns[&#34;{}_centroids&#34;.format(use_rep)][:, 0],
            y=adata.uns[&#34;{}_centroids&#34;.format(use_rep)][:, 1],
            s=ctr_size,
            c=colors,
            edgecolor=&#34;none&#34;,
        )
    else:
        pos = dict(zip(clu_names, adata.uns[&#34;{}_centroids&#34;.format(use_rep)][:, :2]))
        nx.draw_networkx(
            adata.uns[&#34;{}_centroid_MST&#34;.format(use_rep)],
            pos=pos,
            ax=self.ax,
            with_labels=False,
            width=2,
            node_size=ctr_size,
            node_color=colors,
        )
        # highlight edges if desired
        if highlight_edges:
            nx.draw_networkx_edges(
                adata.uns[&#34;{}_centroid_MST&#34;.format(use_rep)],
                pos=pos,
                ax=self.ax,
                edgelist=highlight_edges,
                width=5,
                edge_color=&#34;red&#34;,
            )

    if save_to is None:
        return
    else:
        plt.savefig(fname=save_to, transparent=True, bbox_inches=&#34;tight&#34;, dpi=1000)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="fcc_utils.SP_plot"><code class="flex name class">
<span>class <span class="ident">SP_plot</span></span>
<span>(</span><span>pre_norm, post_norm, figsize=(4, 4), labels=['Native', 'Latent'])</span>
</code></dt>
<dd>
<div class="desc"><p>Class defining pretty plots for structural evaluation of dimension-reduced
embeddings such as PCA, t-SNE, and UMAP</p>
<h2 id="attributes">Attributes</h2>
<p>.figsize : tuple of float
the size of the figure object on which data will be plotted
.fig : matplotlib.figure
the figure object on which data will be plotted
.ax : matplotlib.axes.ax
the axes within <code>self.fig</code>
.palette : sns.cubehelix_palette()
color palette to use for coloring <code>seaborn</code> plots
.cmap : matplotlib.pyplot.cmap
color map to use for plotting; default="cubehelix" from <code>seaborn</code>
.pre : np.array
flattened vector of normalized, unique cell-cell distances
"pre-transformation". upper triangle of cell-cell distance matrix, flattened
to vector of shape ((n_cells^2)/2)-n_cells.
.post : np.array
flattened vector of normalized, unique cell-cell distances
"post-transformation". upper triangle of cell-cell distance matrix, flattened
to vector of shape ((n_cells^2)/2)-n_cells.
.labels : list of str
name of pre- and post-transformation spaces for legend (plot_cell_distances,
plot_distributions, plot_cumulative_distributions) or axis labels
(plot_distance_correlation, joint_plot_distance_correlation) as list of two
strings. False to exclude labels.</p>
<h2 id="methods">Methods</h2>
<p>.plot_cell_distances()
plots all unique cell-cell distances before and after some transformation
.plot_distributions()
plots probability distributions for all unique cell-cell distances before and
after some transformation
.plot_cumulative_distributions()
plots cumulative probability distributions for all unique cell-cell distances
before and after some transformation
.plot_distance_correlation()
plots correlation of all unique cell-cell distances before and after some
transformation
.joint_plot_distance_correlation()
plots correlation of all unique cell-cell distances before and after some
transformation. includes marginal plots of each distribution.</p>
<p>Initializes SP plot class</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>pre_norm</code></strong> :&ensp;<code>np.array</code></dt>
<dd>flattened vector of normalized, unique cell-cell distances
"pre-transformation". upper triangle of cell-cell distance matrix, flattened
to vector of shape ((n_cells^2)/2)-n_cells.</dd>
<dt><strong><code>post_norm</code></strong> :&ensp;<code>np.array</code></dt>
<dd>flattened vector of normalized, unique cell-cell distances
"post-transformation". upper triangle of cell-cell distance matrix, flattened
to vector of shape ((n_cells^2)/2)-n_cells.</dd>
<dt><strong><code>figsize</code></strong> :&ensp;<code>tuple</code> of <code>float</code>, optional <code>(default=(4,4))</code></dt>
<dd>the size of the figure object on which data will be plotted</dd>
<dt><strong><code>labels</code></strong> :&ensp;<code>list</code> of <code>str</code>, optional <code>(default=["Native","Latent"])</code></dt>
<dd>name of pre- and post-transformation spaces for legend (plot_cell_distances,
plot_distributions, plot_cumulative_distributions) or axis labels
(plot_distance_correlation, joint_plot_distance_correlation) as list of two
strings. False to exclude labels.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Initializes <code>self.fig</code> and <code>self.ax</code> according to input specs</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SP_plot:
    &#34;&#34;&#34;
    Class defining pretty plots for structural evaluation of dimension-reduced 
    embeddings such as PCA, t-SNE, and UMAP

    Attributes
    ----------

    .figsize : tuple of float
        the size of the figure object on which data will be plotted
    .fig : matplotlib.figure
        the figure object on which data will be plotted
    .ax : matplotlib.axes.ax
        the axes within `self.fig`
    .palette : sns.cubehelix_palette()
        color palette to use for coloring `seaborn` plots
    .cmap : matplotlib.pyplot.cmap
        color map to use for plotting; default=&#34;cubehelix&#34; from `seaborn`
    .pre : np.array
        flattened vector of normalized, unique cell-cell distances 
        &#34;pre-transformation&#34;. upper triangle of cell-cell distance matrix, flattened 
        to vector of shape ((n_cells^2)/2)-n_cells.
    .post : np.array
        flattened vector of normalized, unique cell-cell distances 
        &#34;post-transformation&#34;. upper triangle of cell-cell distance matrix, flattened 
        to vector of shape ((n_cells^2)/2)-n_cells.
    .labels : list of str
        name of pre- and post-transformation spaces for legend (plot_cell_distances, 
        plot_distributions, plot_cumulative_distributions) or axis labels 
        (plot_distance_correlation, joint_plot_distance_correlation) as list of two 
        strings. False to exclude labels.

    Methods
    -------

    .plot_cell_distances()
        plots all unique cell-cell distances before and after some transformation
    .plot_distributions()
        plots probability distributions for all unique cell-cell distances before and 
        after some transformation
    .plot_cumulative_distributions()
        plots cumulative probability distributions for all unique cell-cell distances 
        before and after some transformation
    .plot_distance_correlation()
        plots correlation of all unique cell-cell distances before and after some 
        transformation
    .joint_plot_distance_correlation()
        plots correlation of all unique cell-cell distances before and after some 
        transformation. includes marginal plots of each distribution.
    &#34;&#34;&#34;

    def __init__(
        self, pre_norm, post_norm, figsize=(4, 4), labels=[&#34;Native&#34;, &#34;Latent&#34;]
    ):
        &#34;&#34;&#34;
        Initializes SP plot class

        Parameters
        ----------

        pre_norm : np.array
            flattened vector of normalized, unique cell-cell distances 
            &#34;pre-transformation&#34;. upper triangle of cell-cell distance matrix, flattened 
            to vector of shape ((n_cells^2)/2)-n_cells.
        post_norm : np.array
            flattened vector of normalized, unique cell-cell distances 
            &#34;post-transformation&#34;. upper triangle of cell-cell distance matrix, flattened 
            to vector of shape ((n_cells^2)/2)-n_cells.
        figsize : tuple of float, optional (default=(4,4))
            the size of the figure object on which data will be plotted
        labels : list of str, optional (default=[&#34;Native&#34;,&#34;Latent&#34;])
            name of pre- and post-transformation spaces for legend (plot_cell_distances, 
            plot_distributions, plot_cumulative_distributions) or axis labels 
            (plot_distance_correlation, joint_plot_distance_correlation) as list of two 
            strings. False to exclude labels.

        Returns
        -------

        Initializes `self.fig` and `self.ax` according to input specs
        &#34;&#34;&#34;
        self.figsize = figsize
        self.fig, self.ax = plt.subplots(1, figsize=self.figsize)
        self.palette = sns.cubehelix_palette()
        self.cmap = sns.cubehelix_palette(as_cmap=True)
        self.pre = pre_norm
        self.post = post_norm
        self.labels = labels

        plt.tick_params(labelbottom=False, labelleft=False)
        sns.despine()
        plt.tight_layout()

    def plot_cell_distances(self, legend=True, save_to=None):
        &#34;&#34;&#34;
        Plots all unique cell-cell distances before and after some transformation

        Parameters
        ----------

        legend : bool, optional (default=True)
            display legend on plot
        save_to : str, optional (default=None)
            path to `.png` file to save output. do not save if None

        Returns
        -------

        `self.fig`, `self.ax` edited; plot saved to `.png` file if `save_to` is not 
        None
        &#34;&#34;&#34;
        plt.plot(self.pre, alpha=0.7, label=self.labels[0], color=self.palette[-1])
        plt.plot(self.post, alpha=0.7, label=self.labels[1], color=self.palette[2])
        if legend:
            plt.legend(loc=&#34;best&#34;, fontsize=&#34;xx-large&#34;)
        else:
            plt.legend()
            self.ax.legend().remove()

        if save_to is None:
            return
        else:
            plt.savefig(fname=save_to, transparent=True, bbox_inches=&#34;tight&#34;, dpi=1000)

    def plot_distributions(self, legend=True, save_to=None):
        &#34;&#34;&#34;
        Plots probability distributions for all unique cell-cell distances before and 
        after some transformation

        Parameters
        ----------

        legend : bool, optional (default=True)
            display legend on plot
        save_to : str, optional (default=None)
            path to `.png` file to save output. do not save if None

        Returns
        -------

        `self.fig`, `self.ax` edited; plot saved to `.png` file if `save_to` is not 
        None
        &#34;&#34;&#34;
        sns.distplot(
            self.pre, hist=False, kde=True, label=self.labels[0], color=self.palette[-1]
        )
        sns.distplot(
            self.post, hist=False, kde=True, label=self.labels[1], color=self.palette[2]
        )
        if legend:
            plt.legend(loc=&#34;best&#34;, fontsize=&#34;xx-large&#34;)
        else:
            plt.legend()
            self.ax.legend().remove()

        if save_to is None:
            return
        else:
            plt.savefig(fname=save_to, transparent=True, bbox_inches=&#34;tight&#34;, dpi=1000)

    def plot_cumulative_distributions(self, legend=True, save_to=None):
        &#34;&#34;&#34;
        Plots cumulative probability distributions for all unique cell-cell distances 
        before and after some transformation

        Parameters
        ----------

        legend : bool, optional (default=True)
            display legend on plot
        save_to : str, optional (default=None)
            path to `.png` file to save output. do not save if None

        Returns
        -------

        `self.fig`, `self.ax` edited; plot saved to `.png` file if `save_to` is not 
        None
        &#34;&#34;&#34;
        num_bins = int(len(self.pre) / 100)
        pre_counts, pre_bin_edges = np.histogram(self.pre, bins=num_bins)
        pre_cdf = np.cumsum(pre_counts)
        post_counts, post_bin_edges = np.histogram(self.post, bins=num_bins)
        post_cdf = np.cumsum(post_counts)
        plt.plot(
            pre_bin_edges[1:],
            pre_cdf / pre_cdf[-1],
            label=self.labels[0],
            color=self.palette[-1],
        )
        plt.plot(
            post_bin_edges[1:],
            post_cdf / post_cdf[-1],
            label=self.labels[1],
            color=self.palette[2],
        )
        if legend:
            plt.legend(loc=&#34;lower right&#34;, fontsize=&#34;xx-large&#34;)
        else:
            plt.legend()
            self.ax.legend().remove()

        if save_to is None:
            return
        else:
            plt.savefig(fname=save_to, transparent=True, bbox_inches=&#34;tight&#34;, dpi=1000)

    def plot_distance_correlation(self, save_to=None):
        &#34;&#34;&#34;
        Plots correlation of all unique cell-cell distances before and after some 
        transformation

        Parameters
        ----------

        save_to : str, optional (default=None)
            path to `.png` file to save output. do not save if None

        Returns
        -------

        `self.fig`, `self.ax` edited; plot saved to `.png` file if `save_to` is not 
        None
        &#34;&#34;&#34;
        plt.hist2d(x=self.pre, y=self.post, bins=50, cmap=self.cmap)
        plt.plot(
            np.linspace(max(min(self.pre), min(self.post)), 1, 100),
            np.linspace(max(min(self.pre), min(self.post)), 1, 100),
            linestyle=&#34;dashed&#34;,
            color=self.palette[-1],
        )  # plot identity line as reference for regression
        if self.labels:
            plt.xlabel(self.labels[0], fontsize=&#34;xx-large&#34;, color=self.palette[-1])
            plt.ylabel(self.labels[1], fontsize=&#34;xx-large&#34;, color=self.palette[2])

        if save_to is None:
            return
        else:
            plt.savefig(fname=save_to, transparent=True, bbox_inches=&#34;tight&#34;, dpi=1000)

    def joint_plot_distance_correlation(self, save_to=None):
        &#34;&#34;&#34;
        Plots correlation of all unique cell-cell distances before and after some 
        transformation. includes marginal plots of each distribution.

        Parameters
        ----------

        save_to : str, optional (default=None)
            path to `.png` file to save output. do not save if None

        Returns
        -------

        `self.fig`, `self.ax` edited; plot saved to `.png` file if `save_to` is not 
        None
        &#34;&#34;&#34;
        plt.close()  # close matplotlib figure from __init__() and start over with seaborn.JointGrid()
        self.fig = sns.JointGrid(
            x=self.pre, y=self.post, space=0, height=self.figsize[0]
        )
        self.fig.plot_joint(plt.hist2d, bins=50, cmap=self.cmap)
        sns.kdeplot(
            x=self.pre,
            color=self.palette[-1],
            shade=False,
            bw_method=0.01,
            ax=self.fig.ax_marg_x,
        )
        sns.kdeplot(
            y=self.post,
            color=self.palette[2],
            shade=False,
            bw_method=0.01,
            ax=self.fig.ax_marg_y,
        )
        self.fig.ax_joint.plot(
            np.linspace(max(min(self.pre), min(self.post)), 1, 100),
            np.linspace(max(min(self.pre), min(self.post)), 1, 100),
            linestyle=&#34;dashed&#34;,
            color=self.palette[-1],
        )  # plot identity line as reference for regression
        if self.labels:
            plt.xlabel(self.labels[0], fontsize=&#34;xx-large&#34;, color=self.palette[-1])
            plt.ylabel(self.labels[1], fontsize=&#34;xx-large&#34;, color=self.palette[2])

        plt.tick_params(labelbottom=False, labelleft=False)

        if save_to is None:
            return
        else:
            plt.savefig(fname=save_to, transparent=True, bbox_inches=&#34;tight&#34;, dpi=1000)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="fcc_utils.SP_plot.joint_plot_distance_correlation"><code class="name flex">
<span>def <span class="ident">joint_plot_distance_correlation</span></span>(<span>self, save_to=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots correlation of all unique cell-cell distances before and after some
transformation. includes marginal plots of each distribution.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>save_to</code></strong> :&ensp;<code>str</code>, optional <code>(default=None)</code></dt>
<dd>path to <code>.png</code> file to save output. do not save if None</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>self.fig</code>, <code>self.ax</code> edited; plot saved to <code>.png</code> file if <code>save_to</code> is not</dt>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def joint_plot_distance_correlation(self, save_to=None):
    &#34;&#34;&#34;
    Plots correlation of all unique cell-cell distances before and after some 
    transformation. includes marginal plots of each distribution.

    Parameters
    ----------

    save_to : str, optional (default=None)
        path to `.png` file to save output. do not save if None

    Returns
    -------

    `self.fig`, `self.ax` edited; plot saved to `.png` file if `save_to` is not 
    None
    &#34;&#34;&#34;
    plt.close()  # close matplotlib figure from __init__() and start over with seaborn.JointGrid()
    self.fig = sns.JointGrid(
        x=self.pre, y=self.post, space=0, height=self.figsize[0]
    )
    self.fig.plot_joint(plt.hist2d, bins=50, cmap=self.cmap)
    sns.kdeplot(
        x=self.pre,
        color=self.palette[-1],
        shade=False,
        bw_method=0.01,
        ax=self.fig.ax_marg_x,
    )
    sns.kdeplot(
        y=self.post,
        color=self.palette[2],
        shade=False,
        bw_method=0.01,
        ax=self.fig.ax_marg_y,
    )
    self.fig.ax_joint.plot(
        np.linspace(max(min(self.pre), min(self.post)), 1, 100),
        np.linspace(max(min(self.pre), min(self.post)), 1, 100),
        linestyle=&#34;dashed&#34;,
        color=self.palette[-1],
    )  # plot identity line as reference for regression
    if self.labels:
        plt.xlabel(self.labels[0], fontsize=&#34;xx-large&#34;, color=self.palette[-1])
        plt.ylabel(self.labels[1], fontsize=&#34;xx-large&#34;, color=self.palette[2])

    plt.tick_params(labelbottom=False, labelleft=False)

    if save_to is None:
        return
    else:
        plt.savefig(fname=save_to, transparent=True, bbox_inches=&#34;tight&#34;, dpi=1000)</code></pre>
</details>
</dd>
<dt id="fcc_utils.SP_plot.plot_cell_distances"><code class="name flex">
<span>def <span class="ident">plot_cell_distances</span></span>(<span>self, legend=True, save_to=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots all unique cell-cell distances before and after some transformation</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>legend</code></strong> :&ensp;<code>bool</code>, optional <code>(default=True)</code></dt>
<dd>display legend on plot</dd>
<dt><strong><code>save_to</code></strong> :&ensp;<code>str</code>, optional <code>(default=None)</code></dt>
<dd>path to <code>.png</code> file to save output. do not save if None</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>self.fig</code>, <code>self.ax</code> edited; plot saved to <code>.png</code> file if <code>save_to</code> is not</dt>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_cell_distances(self, legend=True, save_to=None):
    &#34;&#34;&#34;
    Plots all unique cell-cell distances before and after some transformation

    Parameters
    ----------

    legend : bool, optional (default=True)
        display legend on plot
    save_to : str, optional (default=None)
        path to `.png` file to save output. do not save if None

    Returns
    -------

    `self.fig`, `self.ax` edited; plot saved to `.png` file if `save_to` is not 
    None
    &#34;&#34;&#34;
    plt.plot(self.pre, alpha=0.7, label=self.labels[0], color=self.palette[-1])
    plt.plot(self.post, alpha=0.7, label=self.labels[1], color=self.palette[2])
    if legend:
        plt.legend(loc=&#34;best&#34;, fontsize=&#34;xx-large&#34;)
    else:
        plt.legend()
        self.ax.legend().remove()

    if save_to is None:
        return
    else:
        plt.savefig(fname=save_to, transparent=True, bbox_inches=&#34;tight&#34;, dpi=1000)</code></pre>
</details>
</dd>
<dt id="fcc_utils.SP_plot.plot_cumulative_distributions"><code class="name flex">
<span>def <span class="ident">plot_cumulative_distributions</span></span>(<span>self, legend=True, save_to=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots cumulative probability distributions for all unique cell-cell distances
before and after some transformation</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>legend</code></strong> :&ensp;<code>bool</code>, optional <code>(default=True)</code></dt>
<dd>display legend on plot</dd>
<dt><strong><code>save_to</code></strong> :&ensp;<code>str</code>, optional <code>(default=None)</code></dt>
<dd>path to <code>.png</code> file to save output. do not save if None</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>self.fig</code>, <code>self.ax</code> edited; plot saved to <code>.png</code> file if <code>save_to</code> is not</dt>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_cumulative_distributions(self, legend=True, save_to=None):
    &#34;&#34;&#34;
    Plots cumulative probability distributions for all unique cell-cell distances 
    before and after some transformation

    Parameters
    ----------

    legend : bool, optional (default=True)
        display legend on plot
    save_to : str, optional (default=None)
        path to `.png` file to save output. do not save if None

    Returns
    -------

    `self.fig`, `self.ax` edited; plot saved to `.png` file if `save_to` is not 
    None
    &#34;&#34;&#34;
    num_bins = int(len(self.pre) / 100)
    pre_counts, pre_bin_edges = np.histogram(self.pre, bins=num_bins)
    pre_cdf = np.cumsum(pre_counts)
    post_counts, post_bin_edges = np.histogram(self.post, bins=num_bins)
    post_cdf = np.cumsum(post_counts)
    plt.plot(
        pre_bin_edges[1:],
        pre_cdf / pre_cdf[-1],
        label=self.labels[0],
        color=self.palette[-1],
    )
    plt.plot(
        post_bin_edges[1:],
        post_cdf / post_cdf[-1],
        label=self.labels[1],
        color=self.palette[2],
    )
    if legend:
        plt.legend(loc=&#34;lower right&#34;, fontsize=&#34;xx-large&#34;)
    else:
        plt.legend()
        self.ax.legend().remove()

    if save_to is None:
        return
    else:
        plt.savefig(fname=save_to, transparent=True, bbox_inches=&#34;tight&#34;, dpi=1000)</code></pre>
</details>
</dd>
<dt id="fcc_utils.SP_plot.plot_distance_correlation"><code class="name flex">
<span>def <span class="ident">plot_distance_correlation</span></span>(<span>self, save_to=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots correlation of all unique cell-cell distances before and after some
transformation</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>save_to</code></strong> :&ensp;<code>str</code>, optional <code>(default=None)</code></dt>
<dd>path to <code>.png</code> file to save output. do not save if None</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>self.fig</code>, <code>self.ax</code> edited; plot saved to <code>.png</code> file if <code>save_to</code> is not</dt>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_distance_correlation(self, save_to=None):
    &#34;&#34;&#34;
    Plots correlation of all unique cell-cell distances before and after some 
    transformation

    Parameters
    ----------

    save_to : str, optional (default=None)
        path to `.png` file to save output. do not save if None

    Returns
    -------

    `self.fig`, `self.ax` edited; plot saved to `.png` file if `save_to` is not 
    None
    &#34;&#34;&#34;
    plt.hist2d(x=self.pre, y=self.post, bins=50, cmap=self.cmap)
    plt.plot(
        np.linspace(max(min(self.pre), min(self.post)), 1, 100),
        np.linspace(max(min(self.pre), min(self.post)), 1, 100),
        linestyle=&#34;dashed&#34;,
        color=self.palette[-1],
    )  # plot identity line as reference for regression
    if self.labels:
        plt.xlabel(self.labels[0], fontsize=&#34;xx-large&#34;, color=self.palette[-1])
        plt.ylabel(self.labels[1], fontsize=&#34;xx-large&#34;, color=self.palette[2])

    if save_to is None:
        return
    else:
        plt.savefig(fname=save_to, transparent=True, bbox_inches=&#34;tight&#34;, dpi=1000)</code></pre>
</details>
</dd>
<dt id="fcc_utils.SP_plot.plot_distributions"><code class="name flex">
<span>def <span class="ident">plot_distributions</span></span>(<span>self, legend=True, save_to=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots probability distributions for all unique cell-cell distances before and
after some transformation</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>legend</code></strong> :&ensp;<code>bool</code>, optional <code>(default=True)</code></dt>
<dd>display legend on plot</dd>
<dt><strong><code>save_to</code></strong> :&ensp;<code>str</code>, optional <code>(default=None)</code></dt>
<dd>path to <code>.png</code> file to save output. do not save if None</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>self.fig</code>, <code>self.ax</code> edited; plot saved to <code>.png</code> file if <code>save_to</code> is not</dt>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_distributions(self, legend=True, save_to=None):
    &#34;&#34;&#34;
    Plots probability distributions for all unique cell-cell distances before and 
    after some transformation

    Parameters
    ----------

    legend : bool, optional (default=True)
        display legend on plot
    save_to : str, optional (default=None)
        path to `.png` file to save output. do not save if None

    Returns
    -------

    `self.fig`, `self.ax` edited; plot saved to `.png` file if `save_to` is not 
    None
    &#34;&#34;&#34;
    sns.distplot(
        self.pre, hist=False, kde=True, label=self.labels[0], color=self.palette[-1]
    )
    sns.distplot(
        self.post, hist=False, kde=True, label=self.labels[1], color=self.palette[2]
    )
    if legend:
        plt.legend(loc=&#34;best&#34;, fontsize=&#34;xx-large&#34;)
    else:
        plt.legend()
        self.ax.legend().remove()

    if save_to is None:
        return
    else:
        plt.savefig(fname=save_to, transparent=True, bbox_inches=&#34;tight&#34;, dpi=1000)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="fcc_utils.arcsinh" href="#fcc_utils.arcsinh">arcsinh</a></code></li>
<li><code><a title="fcc_utils.cluster_arrangement_sc" href="#fcc_utils.cluster_arrangement_sc">cluster_arrangement_sc</a></code></li>
<li><code><a title="fcc_utils.distance_stats" href="#fcc_utils.distance_stats">distance_stats</a></code></li>
<li><code><a title="fcc_utils.find_centroids" href="#fcc_utils.find_centroids">find_centroids</a></code></li>
<li><code><a title="fcc_utils.knn_graph" href="#fcc_utils.knn_graph">knn_graph</a></code></li>
<li><code><a title="fcc_utils.knn_preservation" href="#fcc_utils.knn_preservation">knn_preservation</a></code></li>
<li><code><a title="fcc_utils.structure_preservation_sc" href="#fcc_utils.structure_preservation_sc">structure_preservation_sc</a></code></li>
<li><code><a title="fcc_utils.subset_uns_by_ID" href="#fcc_utils.subset_uns_by_ID">subset_uns_by_ID</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="fcc_utils.DR_plot" href="#fcc_utils.DR_plot">DR_plot</a></code></h4>
<ul class="">
<li><code><a title="fcc_utils.DR_plot.plot" href="#fcc_utils.DR_plot.plot">plot</a></code></li>
<li><code><a title="fcc_utils.DR_plot.plot_IDs" href="#fcc_utils.DR_plot.plot_IDs">plot_IDs</a></code></li>
<li><code><a title="fcc_utils.DR_plot.plot_centroids" href="#fcc_utils.DR_plot.plot_centroids">plot_centroids</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fcc_utils.SP_plot" href="#fcc_utils.SP_plot">SP_plot</a></code></h4>
<ul class="">
<li><code><a title="fcc_utils.SP_plot.joint_plot_distance_correlation" href="#fcc_utils.SP_plot.joint_plot_distance_correlation">joint_plot_distance_correlation</a></code></li>
<li><code><a title="fcc_utils.SP_plot.plot_cell_distances" href="#fcc_utils.SP_plot.plot_cell_distances">plot_cell_distances</a></code></li>
<li><code><a title="fcc_utils.SP_plot.plot_cumulative_distributions" href="#fcc_utils.SP_plot.plot_cumulative_distributions">plot_cumulative_distributions</a></code></li>
<li><code><a title="fcc_utils.SP_plot.plot_distance_correlation" href="#fcc_utils.SP_plot.plot_distance_correlation">plot_distance_correlation</a></code></li>
<li><code><a title="fcc_utils.SP_plot.plot_distributions" href="#fcc_utils.SP_plot.plot_distributions">plot_distributions</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>